autofs-5.0.4 - fix st_remove_tasks() locking

From: Ian Kent <raven@themaw.net>

The autofs serialization of state changing during task (mount, umount etc.)
execution was being done twice, with the state queue manager and by using
a pipe to communicate state changes to the handle_mounts() thread. This
required the use of two mutexes which was unnecessary and problematic. So
the pipe was removed and the state queue alone now handles this. When this
was done most of the state queue locking was moved into the state queue
manager functions, however, the locking was inadvertantly left out of the
st_remove_tasks() function.
---

 CHANGELOG      |    1 +
 daemon/state.c |    8 +++++++-
 2 files changed, 8 insertions(+), 1 deletions(-)


diff --git a/CHANGELOG b/CHANGELOG
index a143294..c8b88e4 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -37,6 +37,7 @@
 - clear rpc client on lookup fail.
 - fix lsb init script header.
 - fix memory leak reading master map.
+- fix st_remove_tasks() locking.
 
 4/11/2008 autofs-5.0.4
 -----------------------
diff --git a/daemon/state.c b/daemon/state.c
index 417fde1..533e241 100644
--- a/daemon/state.c
+++ b/daemon/state.c
@@ -783,10 +783,14 @@ void st_remove_tasks(struct autofs_point *ap)
 	struct state_queue *task, *waiting;
 	int status;
 
+	st_mutex_lock();
+
 	head = &state_queue;
 
-	if (list_empty(head))
+	if (list_empty(head)) {
+		st_mutex_unlock();
 		return;
+	}
 
 	p = head->next;
 	while (p != head) {
@@ -823,6 +827,8 @@ void st_remove_tasks(struct autofs_point *ap)
 	if (status)
 		fatal(status);
 
+	st_mutex_unlock();
+
 	return;
 }
 
