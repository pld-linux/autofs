autofs-5.0.4 - mannual umount recovery fixes

From: Ian Kent <raven@themaw.net>

Check for the absence of a mount before doing the manual umount
checks and check ioctlfd is valid seperately. Take a write lock
on the map entry mutex to ensure any mount request is complete
before checking.
---

 CHANGELOG         |    1 +
 daemon/direct.c   |    4 ++--
 daemon/indirect.c |   37 +++++++++++++++++++++++--------------
 3 files changed, 26 insertions(+), 16 deletions(-)


diff --git a/CHANGELOG b/CHANGELOG
index f0d0e58..05e0206 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -54,6 +54,7 @@
 - fix notify mount message path.
 - remount we created mount point fix.
 - fix double free in sasl_bind().
+- mannual umount recovery fixes.
 
 4/11/2008 autofs-5.0.4
 -----------------------
diff --git a/daemon/direct.c b/daemon/direct.c
index 74a9acc..7b02c7a 100644
--- a/daemon/direct.c
+++ b/daemon/direct.c
@@ -889,9 +889,9 @@ void *expire_proc_direct(void *arg)
 			/* Check for manual umount */
 			cache_writelock(me->mc);
 			if (me->ioctlfd != -1 && 
-			    fstat(ioctlfd, &st) != -1 &&
+			    fstat(me->ioctlfd, &st) != -1 &&
 			    !count_mounts(ap->logopt, next->path, st.st_dev)) {
-				ops->close(ap->logopt, ioctlfd);
+				ops->close(ap->logopt, me->ioctlfd);
 				me->ioctlfd = -1;
 				cache_unlock(me->mc);
 				pthread_setcancelstate(cur_state, NULL);
diff --git a/daemon/indirect.c b/daemon/indirect.c
index 463b39c..8025ee4 100644
--- a/daemon/indirect.c
+++ b/daemon/indirect.c
@@ -437,7 +437,19 @@ void *expire_proc_indirect(void *arg)
 				struct mapent *me = NULL;
 				struct stat st;
 
-				master_source_readlock(ap->entry);
+				/* It's got a mount, deal with in the outer loop */
+				if (is_mounted(_PATH_MOUNTED, next->path, MNTS_REAL)) {
+					pthread_setcancelstate(cur_state, NULL);
+					continue;
+				}
+
+				/* Don't touch submounts */
+				if (master_find_submount(ap, next->path)) {
+					pthread_setcancelstate(cur_state, NULL);
+					continue;
+				}
+
+				master_source_writelock(ap->entry);
 
 				map = ap->entry->maps;
 				while (map) {
@@ -456,20 +468,17 @@ void *expire_proc_indirect(void *arg)
 					continue;
 				}
 
+				if (me->ioctlfd == -1) {
+					cache_unlock(mc);
+					master_source_unlock(ap->entry);
+					pthread_setcancelstate(cur_state, NULL);
+					continue;
+				}
+
 				/* Check for manual umount */
-				if (me->ioctlfd != -1 &&
-				    (fstat(me->ioctlfd, &st) == -1 ||
-				     !count_mounts(ap->logopt, me->key, st.st_dev))) {
-					if (is_mounted(_PROC_MOUNTS, me->key, MNTS_REAL)) {
-						error(ap->logopt,
-						      "error: possible mtab mismatch %s",
-						      me->key);
-						cache_unlock(mc);
-						master_source_unlock(ap->entry);
-						pthread_setcancelstate(cur_state, NULL);
-						continue;
-					}
-					close(me->ioctlfd);
+				if (fstat(me->ioctlfd, &st) == -1 ||
+				    !count_mounts(ap->logopt, me->key, st.st_dev)) {
+					ops->close(ap->logopt, me->ioctlfd);
 					me->ioctlfd = -1;
 				}
 
