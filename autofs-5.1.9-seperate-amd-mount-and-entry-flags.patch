commit a2002247e16ef60efe049e04119a9c92694cbfe1
Author: Ian Kent <raven@themaw.net>
Date:   Tue Jul 9 14:59:40 2024 +0800

    autofs-5.1.9 - seperate amd mount and entry flags
    
    We are running out of flags for amd mounts, seperate the mount flags
    from the defaults and entry flags and add a new amd entry flags field.
    
    Signed-off-by: Ian Kent <raven@themaw.net>

diff --git a/CHANGELOG b/CHANGELOG
index b337eeb36..635f6c90b 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -11,6 +11,7 @@
 - refactor umount_amd_ext_mount().
 - add flags argument to amd do_program_mount().
 - fix amd cache options not copied.
+- seperate amd mount and entry flags.
 
 02/11/2023 autofs-5.1.9
 - fix kernel mount status notification.
diff --git a/include/parse_amd.h b/include/parse_amd.h
index 81506cbd9..46f809146 100644
--- a/include/parse_amd.h
+++ b/include/parse_amd.h
@@ -33,12 +33,12 @@
 #define AMD_MOUNT_TYPE_PROGRAM	0x00004000
 #define AMD_MOUNT_TYPE_MASK	0x0000ffff
 
-#define AMD_ENTRY_CUT		0x00010000
-#define AMD_ENTRY_MASK		0x00ff0000
+#define AMD_DEFAULTS_MERGE	0x0001
+#define AMD_DEFAULTS_RESET	0x0002
+#define AMD_DEFAULTS_MASK	0x00ff
 
-#define AMD_DEFAULTS_MERGE	0x01000000
-#define AMD_DEFAULTS_RESET	0x02000000
-#define AMD_DEFAULTS_MASK	0xff000000
+#define AMD_ENTRY_CUT		0x0100
+#define AMD_ENTRY_MASK		0xff00
 
 #define AMD_CACHE_OPTION_NONE	0x0000
 #define AMD_CACHE_OPTION_INC	0x0001
@@ -50,6 +50,7 @@ struct amd_entry {
 	char *path;
 	unsigned long flags;
 	unsigned int cache_opts;
+	unsigned int entry_flags;
 	char *type;
 	char *map_type;
 	char *pref;
diff --git a/modules/amd_parse.y b/modules/amd_parse.y
index 603ec7888..9ea77dac7 100644
--- a/modules/amd_parse.y
+++ b/modules/amd_parse.y
@@ -155,7 +155,7 @@ location_selection_list: location
 	}
 	| location_selection_list SPACE CUT SPACE location
 	{
-		entry.flags |= AMD_ENTRY_CUT;
+		entry.entry_flags |= AMD_ENTRY_CUT;
 		if (!add_location()) {
 			amd_msg("failed to allocate new location");
 			YYABORT;
@@ -168,11 +168,11 @@ location: location_entry
 	}
 	| HYPHEN location_entry
 	{
-		entry.flags |= AMD_DEFAULTS_MERGE;
+		entry.entry_flags |= AMD_DEFAULTS_MERGE;
 	}
 	| HYPHEN
 	{
-		entry.flags |= AMD_DEFAULTS_RESET;
+		entry.entry_flags |= AMD_DEFAULTS_RESET;
 	}
 	;
 
@@ -889,6 +889,7 @@ static int add_location(void)
 	}
 	new->flags = entry.flags;
 	new->cache_opts = entry.cache_opts;
+	new->entry_flags = entry.entry_flags;
 	new->type = entry.type;
 	new->map_type = entry.map_type;
 	new->pref = entry.pref;
diff --git a/modules/parse_amd.c b/modules/parse_amd.c
index d70eb1693..0fb99862f 100644
--- a/modules/parse_amd.c
+++ b/modules/parse_amd.c
@@ -2029,13 +2029,13 @@ static struct amd_entry *select_default_entry(struct autofs_point *ap,
 
 		p = p->next;
 
-		if (this->flags & AMD_DEFAULTS_MERGE) {
+		if (this->entry_flags & AMD_DEFAULTS_MERGE) {
 			if (entry_default)
 				free_amd_entry(entry_default);
 			list_del_init(&this->list);
 			entry_default = this;
 			continue;
-		} else if (this->flags & AMD_DEFAULTS_RESET) {
+		} else if (this->entry_flags & AMD_DEFAULTS_RESET) {
 			struct amd_entry *new;
 			new = dup_defaults_entry(defaults_entry);
 			if (new) {
@@ -2266,14 +2266,14 @@ int parse_mount(struct autofs_point *ap, struct map_source *map,
 		struct amd_entry *this = list_entry(p, struct amd_entry, list);
 		p = p->next;
 
-		if (this->flags & AMD_DEFAULTS_MERGE) {
+		if (this->entry_flags & AMD_DEFAULTS_MERGE) {
 			free_amd_entry(cur_defaults);
 			list_del_init(&this->list);
 			cur_defaults = this;
 			update_with_defaults(defaults_entry, cur_defaults, sv);
 			debug(ap->logopt, "merged /defaults entry with defaults");
 			continue;
-		} else if (this->flags & AMD_DEFAULTS_RESET) {
+		} else if (this->entry_flags & AMD_DEFAULTS_RESET) {
 			struct amd_entry *nd, *new;
 			struct substvar *nsv = NULL;
 
@@ -2298,7 +2298,7 @@ int parse_mount(struct autofs_point *ap, struct map_source *map,
 		debug(ap->logopt, "expand defaults entry");
 		sv = expand_entry(ap, cur_defaults, flags, sv);
 
-		if (this->flags & AMD_ENTRY_CUT && at_least_one) {
+		if (this->entry_flags & AMD_ENTRY_CUT && at_least_one) {
 			info(ap->logopt, MODPREFIX
 			     "at least one entry tried before cut selector, "
 			     "not continuing");
