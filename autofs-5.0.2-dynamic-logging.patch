diff --git a/CHANGELOG b/CHANGELOG
index ca171a4..a7ac9fb 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -35,6 +35,7 @@
 - fix typo in autofs(5) man page.
 - fix map entry expansion when undefined macro is present.
 - remove unused export validation code.
+- add dynamic logging (adapted from v4 patch from Jeff Moyer).
 
 18/06/2007 autofs-5.0.2
 -----------------------
diff --git a/daemon/automount.c b/daemon/automount.c
index 70a3b9d..9ec6923 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -173,7 +173,7 @@ int rmdir_path(struct autofs_point *ap, const char *path, dev_t dev)
 		 */
 		memset(&st, 0, sizeof(st));
 		if (lstat(buf, &st) != 0) {
-			crit(ap->logopt, "lstat of %s failed.", buf);
+			crit(ap->logopt, "lstat of %s failed", buf);
 			return -1;
 		}
 
@@ -234,14 +234,15 @@ int rmdir_path(struct autofs_point *ap, const char *path, dev_t dev)
 /* Like ftw, except fn gets called twice: before a directory is
    entered, and after.  If the before call returns 0, the directory
    isn't entered. */
-static int walk_tree(const char *base, int (*fn) (const char *file,
+static int walk_tree(const char *base, int (*fn) (unsigned logopt,
+						  const char *file,
 						  const struct stat * st,
-						  int, void *), int incl, void *arg)
+						  int, void *), int incl, unsigned logopt, void *arg)
 {
 	char buf[PATH_MAX + 1];
 	struct stat st;
 
-	if (lstat(base, &st) != -1 && (fn) (base, &st, 0, arg)) {
+	if (lstat(base, &st) != -1 && (fn) (logopt, base, &st, 0, arg)) {
 		if (S_ISDIR(st.st_mode)) {
 			struct dirent **de;
 			int n;
@@ -269,18 +270,18 @@ static int walk_tree(const char *base, int (*fn) (const char *file,
 					return -1;
 				}
 
-				walk_tree(buf, fn, 1, arg);
+				walk_tree(buf, fn, 1, logopt, arg);
 				free(de[n]);
 			}
 			free(de);
 		}
 		if (incl)
-			(fn) (base, &st, 1, arg);
+			(fn) (logopt, base, &st, 1, arg);
 	}
 	return 0;
 }
 
-static int rm_unwanted_fn(const char *file, const struct stat *st, int when, void *arg)
+static int rm_unwanted_fn(unsigned logopt, const char *file, const struct stat *st, int when, void *arg)
 {
 	dev_t dev = *(dev_t *) arg;
 	char buf[MAX_ERR_BUF];
@@ -293,41 +294,38 @@ static int rm_unwanted_fn(const char *file, const struct stat *st, int when, voi
 	}
 
 	if (lstat(file, &newst)) {
-		crit(LOGOPT_ANY,
-		     "unable to stat file, possible race condition");
+		crit(logopt, "unable to stat file, possible race condition");
 		return 0;
 	}
 
 	if (newst.st_dev != dev) {
-		crit(LOGOPT_ANY,
-		     "file %s has the wrong device, possible race condition",
+		crit(logopt, "file %s has the wrong device, possible race condition",
 		     file);
 		return 0;
 	}
 
 	if (S_ISDIR(newst.st_mode)) {
-		debug(LOGOPT_ANY, "removing directory %s", file);
+		debug(logopt, "removing directory %s", file);
 		if (rmdir(file)) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			warn(LOGOPT_ANY,
+			warn(logopt,
 			      "unable to remove directory %s: %s", file, estr);
 			return 0;
 		}
 	} else if (S_ISREG(newst.st_mode)) {
-		crit(LOGOPT_ANY,
-		     "attempting to remove files from a mounted "
+		crit(logopt, "attempting to remove files from a mounted "
 		     "directory. file %s", file);
 		return 0;
 	} else if (S_ISLNK(newst.st_mode)) {
-		debug(LOGOPT_ANY, "removing symlink %s", file);
+		debug(logopt, "removing symlink %s", file);
 		unlink(file);
 	}
 	return 1;
 }
 
-void rm_unwanted(const char *path, int incl, dev_t dev)
+void rm_unwanted(unsigned logopt, const char *path, int incl, dev_t dev)
 {
-	walk_tree(path, rm_unwanted_fn, incl, &dev);
+	walk_tree(path, rm_unwanted_fn, incl, logopt, &dev);
 }
 
 struct counter_args {
@@ -335,7 +333,7 @@ struct counter_args {
 	dev_t dev;
 };
 
-static int counter_fn(const char *file, const struct stat *st, int when, void *arg)
+static int counter_fn(unsigned logopt, const char *file, const struct stat *st, int when, void *arg)
 {
 	struct counter_args *counter = (struct counter_args *) arg;
 
@@ -349,14 +347,14 @@ static int counter_fn(const char *file, const struct stat *st, int when, void *a
 }
 
 /* Count mounted filesystems and symlinks */
-int count_mounts(const char *path, dev_t dev)
+int count_mounts(unsigned logopt, const char *path, dev_t dev)
 {
 	struct counter_args counter;
 
 	counter.count = 0;
 	counter.dev = dev;
 	
-	if (walk_tree(path, counter_fn, 0, &counter) == -1)
+	if (walk_tree(path, counter_fn, 0, logopt, &counter) == -1)
 		return -1;
 
 	return counter.count;
@@ -368,9 +366,9 @@ static void check_rm_dirs(struct autofs_point *ap, const char *path, int incl)
 	    (ap->state == ST_SHUTDOWN_PENDING ||
 	     ap->state == ST_SHUTDOWN_FORCE ||
 	     ap->state == ST_SHUTDOWN))
-		rm_unwanted(path, incl, ap->dev);
+		rm_unwanted(ap->logopt, path, incl, ap->dev);
 	else if (ap->ghost && (ap->type == LKP_INDIRECT))
-		rm_unwanted(path, 0, ap->dev);
+		rm_unwanted(ap->logopt, path, 0, ap->dev);
 }
 
 /* Try to purge cache entries kept around due to existing mounts */
@@ -466,7 +464,7 @@ static int umount_subtree_mounts(struct autofs_point *ap, const char *path, unsi
 		cache_multi_lock(me->parent);
 		if (umount_multi_triggers(ap, root, me, base)) {
 			warn(ap->logopt,
-			     "could not umount some offsets under %s", path);
+			     "some offset mounts still present under %s", path);
 			left++;
 		}
 		cache_multi_unlock(me->parent);
@@ -483,7 +481,7 @@ static int umount_subtree_mounts(struct autofs_point *ap, const char *path, unsi
 	 * it already to ensure it's ok to remove any offset triggers.
 	 */
 	if (!is_mm_root && is_mounted(_PATH_MOUNTED, path, MNTS_REAL)) {
-		msg("unmounting dir = %s", path);
+		info(ap->logopt, "unmounting dir = %s", path);
 		if (umount_ent(ap, path)) {
 			warn(ap->logopt, "could not umount dir %s", path);
 			left++;
@@ -576,35 +574,35 @@ int umount_autofs(struct autofs_point *ap, int force)
 	return ret;
 }
 
-int send_ready(int ioctlfd, unsigned int wait_queue_token)
+int send_ready(unsigned logopt, int ioctlfd, unsigned int wait_queue_token)
 {
 	char buf[MAX_ERR_BUF];
 
 	if (wait_queue_token == 0)
 		return 0;
 
-	debug(LOGOPT_NONE, "token = %d", wait_queue_token);
+	debug(logopt, "token = %d", wait_queue_token);
 
 	if (ioctl(ioctlfd, AUTOFS_IOC_READY, wait_queue_token) < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(LOGOPT_ANY, "AUTOFS_IOC_READY: error %s", estr);
+		logerr("AUTOFS_IOC_READY: error %s", estr);
 		return 1;
 	}
 	return 0;
 }
 
-int send_fail(int ioctlfd, unsigned int wait_queue_token)
+int send_fail(unsigned logopt, int ioctlfd, unsigned int wait_queue_token)
 {
 	char buf[MAX_ERR_BUF];
 
 	if (wait_queue_token == 0)
 		return 0;
 
-	debug(LOGOPT_NONE, "token = %d", wait_queue_token);
+	debug(logopt, "token = %d", wait_queue_token);
 
 	if (ioctl(ioctlfd, AUTOFS_IOC_FAIL, wait_queue_token) < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(LOGOPT_ANY, "AUTOFS_IOC_FAIL: error %s", estr);
+		logerr("AUTOFS_IOC_FAIL: error %s", estr);
 		return 1;
 	}
 	return 0;
@@ -649,23 +647,245 @@ static int fullread(int fd, void *ptr, size_t len)
 	return len;
 }
 
+static char *automount_path_to_fifo(unsigned logopt, const char *path)
+{
+	char *fifo_name, *p;
+	int  name_len = strlen(path) + strlen(AUTOFS_LOGPRI_FIFO) + 1;
+	int ret;
+
+	fifo_name = malloc(name_len);
+	if (!fifo_name)
+		return NULL;
+	ret = snprintf(fifo_name, name_len, "%s%s",
+		       AUTOFS_LOGPRI_FIFO, path);
+	if (ret >= name_len) {
+		info(logopt,
+		     "fifo path for \"%s\" truncated to \"%s\".  This may "
+		     "lead to --set-log-priority commands being sent to the "
+		     "wrong automount daemon.", path, fifo_name);
+	}
+
+	/*
+	 *  An automount path can be made up of subdirectories.  So, to
+	 *  create the fifo name, we will just replace instances of '/' with
+	 *  '-'. 
+	 */
+	p = fifo_name + strlen(AUTOFS_LOGPRI_FIFO);
+	while (*p != '\0') {
+		if (*p == '/')
+			*p = '-';
+		p++;
+	}
+
+	debug(logopt, "fifo name %s",fifo_name);
+
+	return fifo_name;
+}
+
+static int create_logpri_fifo(struct autofs_point *ap)
+{
+	int ret = -1;
+	int fd;
+	char *fifo_name;
+
+	fifo_name = automount_path_to_fifo(ap->logopt, ap->path);
+	if (!fifo_name) {
+		crit(ap->logopt, "Failed to allocate memory!");
+		goto out_free; /* free(NULL) is okay */
+	}
+
+	ret = unlink(fifo_name);
+	if (ret != 0 && errno != ENOENT) {
+		crit(ap->logopt,
+		     "Failed to unlink FIFO. Is the automount daemon "
+		     "already running?");
+		goto out_free;
+	}
+
+	ret = mkfifo(fifo_name, S_IRUSR|S_IWUSR);
+	if (ret != 0) {
+		crit(ap->logopt,
+		     "mkfifo for %s returned %d", fifo_name, errno);
+		goto out_free;
+	}
+
+	fd = open(fifo_name, O_RDWR|O_NONBLOCK);
+	if (fd < 0) {
+		crit(ap->logopt,
+		     "Failed to open %s, errno %d", fifo_name, errno);
+		goto out_free;
+	}
+
+	ap->logpri_fifo = fd;
+
+out_free:
+	free(fifo_name);
+	return ret;
+}
+
+static int destroy_logpri_fifo(struct autofs_point *ap)
+{
+	int ret = -1;
+	int fd = ap->logpri_fifo;
+	char *fifo_name;
+
+	fifo_name = automount_path_to_fifo(ap->logopt, ap->path);
+	if (!fifo_name) {
+		crit(ap->logopt, "Failed to allocate memory!");
+		goto out_free; /* free(NULL) is okay */
+	}
+
+	ap->logpri_fifo = -1;
+
+	ret = close(fd);
+	if (ret != 0) {
+		warn(ap->logopt,
+		     "close for fifo %s returned %d", fifo_name, errno);
+	}
+
+	ret = unlink(fifo_name);
+	if (ret != 0) {
+		warn(ap->logopt,
+		     "Failed to unlink FIFO. Was the fifo created OK?");
+	}
+
+out_free:
+	free(fifo_name);
+	return ret;
+}
+
+static void handle_fifo_message(struct autofs_point *ap, int fd)
+{
+	int ret;
+	char buffer[PIPE_BUF];
+	char *end;
+	long pri;
+
+	memset(buffer, 0, sizeof(buffer));
+	ret = read(fd, &buffer, sizeof(buffer));
+	if (ret < 0) {
+		warn(ap->logopt, "read on fifo returned error %d", errno);
+		return;
+	}
+
+	if (ret != 2) {
+		debug(ap->logopt, "expected 2 bytes, received %d.", ret);
+		return;
+	}
+
+	errno = 0;
+	pri = strtol(buffer, &end, 10);
+	if ((pri == LONG_MIN || pri == LONG_MAX) && errno == ERANGE) {
+		debug(ap->logopt, "strtol reported an %s.  Failed to set "
+		      "log priority.", pri == LONG_MIN ? "underflow" : "overflow");
+		return;
+	}
+	if ((pri == 0 && errno == EINVAL) || end == buffer) {
+		debug(ap->logopt, "priority is expected to be an integer "
+		      "in the range 0-7 inclusive.");
+		return;
+	}
+
+	if (pri > LOG_DEBUG || pri < LOG_EMERG) {
+		debug(ap->logopt, "invalid log priority (%ld) received "
+		      "on fifo", pri);
+		return;
+	}
+
+	/*
+	 * OK, the message passed all of the sanity checks.  The
+	 * automounter actually only supports three log priorities.
+	 * Everything is logged at log level debug, deamon messages
+	 * and everything except debug messages are logged with the
+	 * verbose setting and only error and critical messages are
+	 * logged when debugging isn't enabled.
+	 */
+	if (pri >= LOG_WARNING) {
+		if (pri == LOG_DEBUG) {
+			set_log_debug_ap(ap);
+			info(ap->logopt, "Debug logging set for %s", ap->path);
+		} else {
+			set_log_verbose_ap(ap);
+			info(ap->logopt, "Verbose logging set for %s", ap->path);
+		}
+	} else {
+		if (ap->logopt & LOGOPT_ANY)
+			info(ap->logopt, "Basic logging set for %s", ap->path);
+		set_log_norm_ap(ap);
+	}
+}
+
+static int set_log_priority(const char *path, int priority)
+{
+	int fd;
+	char *fifo_name;
+	char buf[2];
+
+	if (priority > LOG_DEBUG || priority < LOG_EMERG) {
+		fprintf(stderr, "Log priority %d is invalid.\n", priority);
+		fprintf(stderr, "Please spcify a number in the range 0-7.\n");
+		return -1;
+	}
+
+	/*
+	 * This is an ascii based protocol, so we want the string
+	 * representation of the integer log priority.
+	 */
+	snprintf(buf, sizeof(buf), "%d", priority);
+
+	fifo_name = automount_path_to_fifo(LOGOPT_NONE, path);
+	if (!fifo_name) {
+		fprintf(stderr, "%s: Failed to allocate memory!\n",
+			__FUNCTION__);
+		return -1;
+	}
+
+	/*
+	 * Specify O_NONBLOCK so that the open will fail if there is no
+	 * daemon reading from the other side of the FIFO.
+	 */
+	fd = open(fifo_name, O_WRONLY|O_NONBLOCK);
+	if (fd < 0) {
+		fprintf(stderr, "%s: open of %s failed with %d\n",
+			__FUNCTION__, fifo_name, errno);
+		free(fifo_name);
+		return -1;
+	}
+
+	if (write(fd, buf, sizeof(buf)) != sizeof(buf)) {
+		fprintf(stderr, "Failed to change logging priority.  ");
+		fprintf(stderr, "write to fifo failed with errno %d.\n",
+			errno);
+		close(fd);
+		free(fifo_name);
+		return -1;
+	}
+	close(fd);
+	free(fifo_name);
+	fprintf(stdout, "Successfully set log priority for %s.\n", path);
+
+	return 0;
+}
+
 static int get_pkt(struct autofs_point *ap, union autofs_packet_union *pkt)
 {
-	struct pollfd fds[2];
+	struct pollfd fds[3];
 	char buf[MAX_ERR_BUF];
 
 	fds[0].fd = ap->pipefd;
 	fds[0].events = POLLIN;
 	fds[1].fd = ap->state_pipe[0];
 	fds[1].events = POLLIN;
+	fds[2].fd = ap->logpri_fifo;
+	fds[2].events = POLLIN;
 
 	for (;;) {
-		if (poll(fds, 2, -1) == -1) {
+		if (poll(fds, 3, -1) == -1) {
 			char *estr;
 			if (errno == EINTR)
 				continue;
 			estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			error(ap->logopt, "poll failed: %s", estr);
+			logerr("poll failed: %s", estr);
 			return -1;
 		}
 
@@ -709,6 +929,11 @@ static int get_pkt(struct autofs_point *ap, union autofs_packet_union *pkt)
 
 		if (fds[0].revents & POLLIN)
 			return fullread(ap->pipefd, pkt, kpkt_len);
+
+		if (fds[2].revents & POLLIN) {
+			debug(ap->logopt, "message pending on control fifo.");
+			handle_fifo_message(ap, fds[2].fd);
+		}
 	}
 }
 
@@ -730,21 +955,93 @@ int do_expire(struct autofs_point *ap, const char *name, int namelen)
 		return 1;
 	}
 
-	msg("expiring path %s", buf);
+	info(ap->logopt, "expiring path %s", buf);
 
 	ret = umount_multi(ap, buf, 1);
 	if (ret == 0)
-		msg("expired %s", buf);
+		info(ap->logopt, "expired %s", buf);
 	else
 		warn(ap->logopt, "couldn't complete expire of %s", buf);
 
 	return ret;
 }
 
+static int autofs_init_ap(struct autofs_point *ap)
+{
+	int pipefd[2], cl_flags;
+
+	if ((ap->state != ST_INIT)) {
+		/* This can happen if an autofs process is already running*/
+		error(ap->logopt, "bad state %d", ap->state);
+		return -1;
+	}
+
+	ap->pipefd = ap->kpipefd = ap->ioctlfd = -1;
+
+	/* Pipe for kernel communications */
+	if (pipe(pipefd) < 0) {
+		crit(ap->logopt,
+		     "failed to create commumication pipe for autofs path %s",
+		     ap->path);
+		free(ap->path);
+		return -1;
+	}
+
+	ap->pipefd = pipefd[0];
+	ap->kpipefd = pipefd[1];
+
+	if ((cl_flags = fcntl(ap->pipefd, F_GETFD, 0)) != -1) {
+		cl_flags |= FD_CLOEXEC;
+		fcntl(ap->pipefd, F_SETFD, cl_flags);
+	}
+
+	if ((cl_flags = fcntl(ap->kpipefd, F_GETFD, 0)) != -1) {
+		cl_flags |= FD_CLOEXEC;
+		fcntl(ap->kpipefd, F_SETFD, cl_flags);
+	}
+
+	/* Pipe state changes from signal handler to main loop */
+	if (pipe(ap->state_pipe) < 0) {
+		crit(ap->logopt,
+		     "failed create state pipe for autofs path %s", ap->path);
+		close(ap->pipefd);
+		close(ap->kpipefd);	/* Close kernel pipe end */
+		free(ap->path);
+		return -1;
+	}
+
+	if ((cl_flags = fcntl(ap->state_pipe[0], F_GETFD, 0)) != -1) {
+		cl_flags |= FD_CLOEXEC;
+		fcntl(ap->state_pipe[0], F_SETFD, cl_flags);
+	}
+
+	if ((cl_flags = fcntl(ap->state_pipe[1], F_GETFD, 0)) != -1) {
+		cl_flags |= FD_CLOEXEC;
+		fcntl(ap->state_pipe[1], F_SETFD, cl_flags);
+	}
+
+	if (create_logpri_fifo(ap) < 0) {
+		crit(ap->logopt,
+		     "failed to create FIFO for path %s\n", ap->path);
+		destroy_logpri_fifo(ap);
+		close(ap->pipefd);
+		close(ap->kpipefd);
+		free(ap->path);
+		close(ap->state_pipe[0]);
+		close(ap->state_pipe[1]);
+		return -1;
+	}
+
+	return 0;
+}
+
 static int mount_autofs(struct autofs_point *ap)
 {
 	int status = 0;
 
+	if (autofs_init_ap(ap) != 0)
+		return -1;
+
 	if (ap->type == LKP_DIRECT)
 		status = mount_autofs_direct(ap);
 	else
@@ -841,9 +1138,8 @@ static void become_daemon(unsigned foreground)
 			fclose(pidfp);
 		} else {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			warn(LOGOPT_ANY,
-			     "failed to write pid file %s: %s",
-			     pid_file, estr);
+			logerr("failed to write pid file %s: %s",
+			       pid_file, estr);
 			pid_file = NULL;
 		}
 	}
@@ -889,12 +1185,12 @@ static void *do_notify_state(void *arg)
 
 	master = mrc.master;
 
-	debug(master->default_logging, "signal %d", sig);
+	debug(master->logopt, "signal %d", sig);
 
 	mrc.signaled = 1;
 	status = pthread_cond_signal(&mrc.cond);
 	if (status) {
-		error(master->default_logging,
+		error(master->logopt,
 		      "failed to signal state notify condition");
 		status = pthread_mutex_unlock(&mrc.mutex);
 		if (status)
@@ -923,7 +1219,7 @@ static pthread_t do_signals(struct master *master, int sig)
 
 	status = pthread_create(&thid, &thread_attr, do_notify_state, &r_sig);
 	if (status) {
-		error(master->default_logging,
+		error(master->logopt,
 		      "mount state notify thread create failed");
 		status = pthread_mutex_unlock(&mrc.mutex);
 		if (status)
@@ -951,6 +1247,7 @@ static pthread_t do_signals(struct master *master, int sig)
 static void *do_read_master(void *arg)
 {
 	struct master *master;
+	unsigned int logopt;
 	time_t age;
 	int readall = 1;
 	int status;
@@ -961,11 +1258,12 @@ static void *do_read_master(void *arg)
 
 	master = mrc.master;
 	age = mrc.age;
+	logopt = master->logopt;
 
 	mrc.signaled = 1;
 	status = pthread_cond_signal(&mrc.cond);
 	if (status) {
-		error(master->default_logging,
+		error(logopt,
 		      "failed to signal master read map condition");
 		master->reading = 0;
 		status = pthread_mutex_unlock(&mrc.mutex);
@@ -989,6 +1287,7 @@ static void *do_read_master(void *arg)
 
 static int do_hup_signal(struct master *master, time_t age)
 {
+	unsigned int logopt = master->logopt;
 	pthread_t thid;
 	int status;
 
@@ -1007,7 +1306,7 @@ static int do_hup_signal(struct master *master, time_t age)
 
 	status = pthread_create(&thid, &thread_attr, do_read_master, NULL);
 	if (status) {
-		error(master->default_logging,
+		error(logopt,
 		      "master read map thread create failed");
 		master->reading = 0;
 		status = pthread_mutex_unlock(&mrc.mutex);
@@ -1062,8 +1361,7 @@ static void *statemachine(void *arg)
 			break;
 
 		default:
-			error(master_list->default_logging,
-			      "got unexpected signal %d!", sig);
+			logerr("got unexpected signal %d!", sig);
 			continue;
 		}
 	}
@@ -1134,10 +1432,11 @@ static void handle_mounts_cleanup(void *arg)
 	struct autofs_point *ap;
 	char path[PATH_MAX + 1];
 	char buf[MAX_ERR_BUF];
-	unsigned int clean = 0, submount;
+	unsigned int clean = 0, submount, logopt;
 
 	ap = (struct autofs_point *) arg;
 
+	logopt = ap->logopt;
 	submount = ap->submount;
 
 	strcpy(path, ap->path);
@@ -1152,6 +1451,7 @@ static void handle_mounts_cleanup(void *arg)
 
 	umount_autofs(ap, 1);
 
+	destroy_logpri_fifo(ap);
 	master_signal_submount(ap, MASTER_SUBMNT_JOIN);
 	master_remove_mapent(ap->entry);
 	master_free_mapent_sources(ap->entry, 1);
@@ -1162,12 +1462,12 @@ static void handle_mounts_cleanup(void *arg)
 	if (clean) {
 		if (rmdir(path) == -1) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			warn(LOGOPT_NONE, "failed to remove dir %s: %s",
+			warn(logopt, "failed to remove dir %s: %s",
 			     path, estr);
 		}
 	}
 
-	msg("shut down path %s", path);
+	info(logopt, "shut down path %s", path);
 
 	/* If we are the last tell the state machine to shutdown */
 	if (!submount && master_list_empty(master_list))
@@ -1190,7 +1490,7 @@ void *handle_mounts(void *arg)
 
 	status = pthread_mutex_lock(&suc.mutex);
 	if (status) {
-		crit(ap->logopt, "failed to lock startup condition mutex!");
+		logerr("failed to lock startup condition mutex!");
 		fatal(status);
 	}
 
@@ -1204,7 +1504,7 @@ void *handle_mounts(void *arg)
 	}
 
 	if (ap->ghost && ap->type != LKP_DIRECT)
-		msg("ghosting enabled");
+		info(ap->logopt, "ghosting enabled");
 
 	suc.status = 0;
 	pthread_cleanup_pop(1);
@@ -1356,6 +1656,8 @@ static void usage(void)
 		"			use ramdom replicated server selection\n"
 		"	-O --global-options\n"
 		"			specify global mount options\n"
+		"	-l --set-log-priority priority path [path,...]\n"
+		"			set daemon log verbosity\n"
 		"	-V --version	print version, build config and exit\n"
 		, program);
 }
@@ -1437,9 +1739,45 @@ static void show_build_info(void)
 	return;
 }
 
+typedef struct _code {
+	char	*c_name;
+	int	c_val;
+} CODE;
+
+CODE prioritynames[] = {
+	{ "alert",	LOG_ALERT },
+	{ "crit",	LOG_CRIT },
+	{ "debug",	LOG_DEBUG },
+	{ "emerg",	LOG_EMERG },
+	{ "err",	LOG_ERR },
+	{ "error",	LOG_ERR },		/* DEPRECATED */
+	{ "info",	LOG_INFO },
+	{ "notice",	LOG_NOTICE },
+	{ "panic", 	LOG_EMERG },		/* DEPRECATED */
+	{ "warn",	LOG_WARNING },		/* DEPRECATED */
+	{ "warning",	LOG_WARNING },
+	{ NULL,		-1 },
+};
+
+static int convert_log_priority(char *priority_name)
+{
+	CODE *priority_mapping;
+
+	for (priority_mapping = prioritynames;
+	     priority_mapping->c_name != NULL;
+	     priority_mapping++) {
+
+		if (!strcasecmp(priority_name, priority_mapping->c_name))
+			return priority_mapping->c_val;
+	}
+
+	return -1;
+}
+
 int main(int argc, char *argv[])
 {
 	int res, opt, status;
+	int logpri = -1;
 	unsigned ghost, logging;
 	unsigned foreground, have_global_options;
 	time_t timeout;
@@ -1457,6 +1795,7 @@ int main(int argc, char *argv[])
 		{"random-multimount-selection", 0, 0, 'r'},
 		{"global-options", 1, 0, 'O'},
 		{"version", 0, 0, 'V'},
+		{"set-log-priority", 1, 0, 'l'},
 		{0, 0, 0, 0}
 	};
 
@@ -1477,7 +1816,7 @@ int main(int argc, char *argv[])
 	foreground = 0;
 
 	opterr = 0;
-	while ((opt = getopt_long(argc, argv, "+hp:t:vdD:fVrO:", long_options, NULL)) != EOF) {
+	while ((opt = getopt_long(argc, argv, "+hp:t:vdD:fVrO:l:", long_options, NULL)) != EOF) {
 		switch (opt) {
 		case 'h':
 			usage();
@@ -1525,6 +1864,23 @@ int main(int argc, char *argv[])
 				program);
 			break;
 
+		case 'l':
+			if (isalpha(*optarg)) {
+				logpri = convert_log_priority(optarg);
+				if (logpri < 0) {
+					fprintf(stderr, "Invalid log priority:"
+						" %s\n", optarg);
+					exit(1);
+				}
+			} else if (isdigit(*optarg)) {
+				logpri = getnumopt(optarg, opt);
+			} else {
+				fprintf(stderr, "non-alphanumeric character "
+					"found in log priority.  Aborting.\n");
+				exit(1);
+			}
+			break;
+
 		case '?':
 		case ':':
 			printf("%s: Ambiguous or unknown options\n", program);
@@ -1548,6 +1904,26 @@ int main(int argc, char *argv[])
 	argv += optind;
 	argc -= optind;
 
+	if (logpri >= 0) {
+		int exit_code = 0;
+		int i;
+
+		/*
+		 * The remaining argv elements are the paths for which
+		 * log priorities must be changed.
+		 */
+		for (i = 0; i < argc; i++) {
+			if (set_log_priority(argv[i], logpri) < 0)
+				exit_code = 1;
+		}
+		if (argc < 1) {
+			fprintf(stderr,
+				"--set-log-priority requires a path.\n");
+			exit_code = 1;
+		}
+		exit(exit_code);
+	}
+
 	if (is_automount_running() > 0) {
 		fprintf(stderr, "%s: program is already running.\n",
 			program);
@@ -1572,7 +1948,7 @@ int main(int argc, char *argv[])
 	rlim.rlim_max = MAX_OPEN_FILES;
 	res = setrlimit(RLIMIT_NOFILE, &rlim);
 	if (res)
-		warn(LOGOPT_NONE,
+		warn(logging,
 		     "can't increase open file limit - continuing");
 
 #if ENABLE_CORES
@@ -1580,7 +1956,7 @@ int main(int argc, char *argv[])
 	rlim.rlim_max = RLIM_INFINITY;
 	res = setrlimit(RLIMIT_CORE, &rlim);
 	if (res)
-		warn(LOGOPT_NONE,
+		warn(logging,
 		     "can't increase core file limit - continuing");
 #endif
 
@@ -1592,15 +1968,14 @@ int main(int argc, char *argv[])
 		master_list = master_new(argv[0], timeout, ghost);
 
 	if (!master_list) {
-		crit(LOGOPT_ANY, "%s: can't create master map %s",
+		logerr("%s: can't create master map %s",
 			program, argv[0]);
 		close(start_pipefd[1]);
 		exit(1);
 	}
 
 	if (pthread_attr_init(&thread_attr)) {
-		crit(LOGOPT_ANY,
-		     "%s: failed to init thread attribute struct!",
+		logerr("%s: failed to init thread attribute struct!",
 		     program);
 		close(start_pipefd[1]);
 		exit(1);
@@ -1608,8 +1983,7 @@ int main(int argc, char *argv[])
 
 	if (pthread_attr_setdetachstate(
 			&thread_attr, PTHREAD_CREATE_DETACHED)) {
-		crit(LOGOPT_ANY,
-		     "%s: failed to set detached thread attribute!",
+		logerr("%s: failed to set detached thread attribute!",
 		     program);
 		close(start_pipefd[1]);
 		exit(1);
@@ -1618,38 +1992,37 @@ int main(int argc, char *argv[])
 #ifdef _POSIX_THREAD_ATTR_STACKSIZE
 	if (pthread_attr_setstacksize(
 			&thread_attr, PTHREAD_STACK_MIN*64)) {
-		crit(LOGOPT_ANY,
-		     "%s: failed to set stack size thread attribute!",
-		     program);
+		logerr("%s: failed to set stack size thread attribute!",
+		       program);
 		close(start_pipefd[1]);
 		exit(1);
 	}
 #endif
 
-	msg("Starting automounter version %s, master map %s",
+	info(logging, "Starting automounter version %s, master map %s",
 		version, master_list->name);
-	msg("using kernel protocol version %d.%02d",
+	info(logging, "using kernel protocol version %d.%02d",
 		get_kver_major(), get_kver_minor());
 
 	status = pthread_key_create(&key_thread_stdenv_vars,
 				key_thread_stdenv_vars_destroy);
 	if (status) {
-		crit(LOGOPT_ANY,
-		     "failed to create thread data key for std env vars!");
+		logerr("%s: failed to create thread data key for std env vars!",
+		       program);
 		master_kill(master_list);
 		close(start_pipefd[1]);
 		exit(1);
 	}
 
 	if (!alarm_start_handler()) {
-		crit(LOGOPT_ANY, "failed to create alarm handler thread!");
+		logerr("%s: failed to create alarm handler thread!", program);
 		master_kill(master_list);
 		close(start_pipefd[1]);
 		exit(1);
 	}
 
 	if (!st_start_handler()) {
-		crit(LOGOPT_ANY, "failed to create FSM handler thread!");
+		logerr("%s: failed to create FSM handler thread!", program);
 		master_kill(master_list);
 		close(start_pipefd[1]);
 		exit(1);
@@ -1685,5 +2058,7 @@ int main(int argc, char *argv[])
 	if (dh)
 		dlclose(dh);
 #endif
+	info(logging, "autofs stopped");
+
 	exit(0);
 }
diff --git a/daemon/direct.c b/daemon/direct.c
index 9a39a6f..4ab4204 100644
--- a/daemon/direct.c
+++ b/daemon/direct.c
@@ -86,61 +86,6 @@ static void mnts_cleanup(void *arg)
 	return;
 }
 
-static int autofs_init_direct(struct autofs_point *ap)
-{
-	int pipefd[2], cl_flags;
-
-	if ((ap->state != ST_INIT)) {
-		/* This can happen if an autofs process is already running*/
-		error(ap->logopt, "bad state %d", ap->state);
-		return -1;
-	}
-
-	ap->pipefd = ap->kpipefd = ap->ioctlfd = -1;
-
-	/* Pipe for kernel communications */
-	if (pipe(pipefd) < 0) {
-		crit(ap->logopt,
-		     "failed to create commumication pipe for autofs path %s",
-		     ap->path);
-		return -1;
-	}
-
-	ap->pipefd = pipefd[0];
-	ap->kpipefd = pipefd[1];
-
-	if ((cl_flags = fcntl(ap->pipefd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->pipefd, F_SETFD, cl_flags);
-	}
-
-	if ((cl_flags = fcntl(ap->kpipefd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->kpipefd, F_SETFD, cl_flags);
-	}
-
-	/* Pipe state changes from signal handler to main loop */
-	if (pipe(ap->state_pipe) < 0) {
-		crit(ap->logopt, "failed create state pipe for autofs path %s",
-		     ap->path);
-		close(ap->pipefd);
-		close(ap->kpipefd);
-		return -1;
-	}
-
-	if ((cl_flags = fcntl(ap->state_pipe[0], F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->state_pipe[0], F_SETFD, cl_flags);
-	}
-
-	if ((cl_flags = fcntl(ap->state_pipe[1], F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->state_pipe[1], F_SETFD, cl_flags);
-	}
-
-	return 0;
-}
-
 int do_umount_autofs_direct(struct autofs_point *ap, struct mnt_list *mnts, struct mapent *me)
 {
 	char buf[MAX_ERR_BUF];
@@ -241,10 +186,10 @@ int do_umount_autofs_direct(struct autofs_point *ap, struct mnt_list *mnts, stru
 
 force_umount:
 	if (rv != 0) {
-		msg("forcing umount of direct mount %s", me->key);
+		info(ap->logopt, "forcing umount of direct mount %s", me->key);
 		rv = umount2(me->key, MNT_DETACH);
 	} else
-		msg("umounted direct mount %s", me->key);
+		info(ap->logopt, "umounted direct mount %s", me->key);
 
 	if (!rv && me->dir_created) {
 		if  (rmdir(me->key) == -1) {
@@ -326,7 +271,7 @@ static int unlink_mount_tree(struct autofs_point *ap, struct list_head *list)
 			continue;
 
 		if (strcmp(mnt->fs_type, "autofs"))
-			rv = spawn_umount(log_debug, "-l", mnt->path, NULL);
+			rv = spawn_umount(ap->logopt, "-l", mnt->path, NULL);
 		else
 			rv = umount2(mnt->path, MNT_DETACH);
 		if (rv == -1) {
@@ -475,13 +420,15 @@ int do_mount_autofs_direct(struct autofs_point *ap, struct mnt_list *mnts, struc
 	ioctl(ioctlfd, AUTOFS_IOC_SETTIMEOUT, &timeout);
 
 	if (ap->exp_timeout)
-		msg("mounted direct mount on %s "
+		info(ap->logopt,
+		    "mounted direct mount on %s "
 		    "with timeout %u, freq %u seconds", me->key,
 		    (unsigned int) ap->exp_timeout,
 		    (unsigned int) ap->exp_runfreq);
 	else
-		msg("mounted direct mount on %s with timeouts disabled",
-		    me->key);
+		info(ap->logopt,
+		     "mounted direct mount on %s with timeouts disabled",
+		     me->key);
 
 	ret = fstat(ioctlfd, &st);
 	if (ret == -1) {
@@ -522,9 +469,6 @@ int mount_autofs_direct(struct autofs_point *ap)
 		return -1;
 	}
 
-	if (autofs_init_direct(ap))
-		return -1;
-
 	/* TODO: check map type */
 	if (lookup_nss_read_map(ap, NULL, now))
 		lookup_prune_cache(ap, now);
@@ -607,7 +551,7 @@ int umount_autofs_offset(struct autofs_point *ap, struct mapent *me)
 		/* offset isn't mounted, return success and try to recover */
 		if (!is_mounted(_PROC_MOUNTS, me->key, MNTS_AUTOFS)) {
 			debug(ap->logopt,
-			      "offset %s unexpectedly not mounted",
+			      "offset %s not mounted",
 			      me->key);
 			return 0;
 		}
@@ -627,7 +571,7 @@ int umount_autofs_offset(struct autofs_point *ap, struct mapent *me)
 		rv = ioctl(ioctlfd, AUTOFS_IOC_ASKUMOUNT, &status);
 		if (rv) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			error(ap->logopt, "ioctl failed: %s", estr);
+			logerr("ioctl failed: %s", estr);
 			return 1;
 		} else if (!status) {
 			if (ap->state != ST_SHUTDOWN_FORCE) {
@@ -692,10 +636,10 @@ int umount_autofs_offset(struct autofs_point *ap, struct mapent *me)
 
 force_umount:
 	if (rv != 0) {
-		msg("forcing umount of offset mount %s", me->key);
+		info(ap->logopt, "forcing umount of offset mount %s", me->key);
 		rv = umount2(me->key, MNT_DETACH);
 	} else
-		msg("umounted offset mount %s", me->key);
+		info(ap->logopt, "umounted offset mount %s", me->key);
 
 	if (!rv && me->dir_created) {
 		if  (rmdir(me->key) == -1) {
@@ -868,7 +812,7 @@ static int expire_direct(int ioctlfd, const char *path, unsigned int when, unsig
 		return 0;
 	}
 
-	retries = (count_mounts(path, st.st_dev) + 1) * EXPIRE_RETRIES;
+	retries = (count_mounts(logopt, path, st.st_dev) + 1) * EXPIRE_RETRIES;
 
 	while (retries--) {
 		struct timespec tm = {0, 100000000};
@@ -1018,7 +962,7 @@ void *expire_proc_direct(void *arg)
 
 			if (me->ioctlfd != -1 && 
 			    fstat(ioctlfd, &st) != -1 &&
-			    !count_mounts(next->path, st.st_dev)) {
+			    !count_mounts(ap->logopt, next->path, st.st_dev)) {
 				close(ioctlfd);
 				me->ioctlfd = -1;
 			}
@@ -1049,6 +993,9 @@ void *expire_proc_direct(void *arg)
 	}
 	pthread_cleanup_pop(1);
 
+	if (left)
+		info(ap->logopt, "%d remaining in %s", left, ap->path);
+
 	ec.status = left;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
@@ -1072,7 +1019,7 @@ static void pending_cond_destroy(void *arg)
 static void expire_send_fail(void *arg)
 {
 	struct pending_args *mt = arg;
-	send_fail(mt->ioctlfd, mt->wait_queue_token);
+	send_fail(mt->ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 }
 
 static void free_pending_args(void *arg)
@@ -1124,14 +1071,14 @@ static void *do_expire_direct(void *arg)
 	status = do_expire(ap, mt->name, len);
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &state);
 	if (status)
-		send_fail(mt->ioctlfd, mt->wait_queue_token);
+		send_fail(ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 	else {
 		struct mapent *me;
 		cache_readlock(mt->mc);
 		me = cache_lookup_distinct(mt->mc, mt->name);
 		me->ioctlfd = -1;
 		cache_unlock(mt->mc);
-		send_ready(mt->ioctlfd, mt->wait_queue_token);
+		send_ready(ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 		close(mt->ioctlfd);
 	}
 	pthread_setcancelstate(state, NULL);
@@ -1194,7 +1141,7 @@ int handle_packet_expire_direct(struct autofs_point *ap, autofs_packet_expire_di
 	if (!mt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 		error(ap->logopt, "malloc: %s", estr);
-		send_fail(me->ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, me->ioctlfd, pkt->wait_queue_token);
 		cache_unlock(mc);
 		pthread_setcancelstate(state, NULL);
 		return 1;
@@ -1223,7 +1170,7 @@ int handle_packet_expire_direct(struct autofs_point *ap, autofs_packet_expire_di
 	status = pthread_create(&thid, &thread_attr, do_expire_direct, mt);
 	if (status) {
 		error(ap->logopt, "expire thread create failed");
-		send_fail(mt->ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, mt->ioctlfd, pkt->wait_queue_token);
 		cache_unlock(mc);
 		expire_mutex_unlock(NULL);
 		pending_cond_destroy(mt);
@@ -1252,7 +1199,7 @@ int handle_packet_expire_direct(struct autofs_point *ap, autofs_packet_expire_di
 static void mount_send_fail(void *arg)
 {
 	struct pending_args *mt = arg;
-	send_fail(mt->ioctlfd, mt->wait_queue_token);
+	send_fail(mt->ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 	close(mt->ioctlfd);
 }
 
@@ -1319,7 +1266,7 @@ static void *do_mount_direct(void *arg)
 
 	pthread_setcancelstate(state, NULL);
 
-	msg("attempting to mount entry %s", mt->name);
+	info(ap->logopt, "attempting to mount entry %s", mt->name);
 
 	/*
 	 * Setup thread specific data values for macro
@@ -1445,16 +1392,16 @@ cont:
 		cache_unlock(mt->mc);
 		if (set_fd) {
 			me->ioctlfd = mt->ioctlfd;
-			send_ready(mt->ioctlfd, mt->wait_queue_token);
+			send_ready(ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 		} else {
-			send_ready(mt->ioctlfd, mt->wait_queue_token);
+			send_ready(ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 			close(mt->ioctlfd);
 		}
-		msg("mounted %s", mt->name);
+		info(ap->logopt, "mounted %s", mt->name);
 	} else {
-		send_fail(mt->ioctlfd, mt->wait_queue_token);
+		send_fail(mt->ap->logopt, mt->ioctlfd, mt->wait_queue_token);
 		close(mt->ioctlfd);
-		msg("failed to mount %s", mt->name);
+		info(ap->logopt, "failed to mount %s", mt->name);
 	}
 	pthread_setcancelstate(state, NULL);
 
@@ -1505,7 +1452,7 @@ int handle_packet_missing_direct(struct autofs_point *ap, autofs_packet_missing_
 		 * Shouldn't happen as the kernel is telling us
 		 * someone has walked on our mount point.
 		 */
-		crit(ap->logopt, "can't find map entry for (%lu,%lu)",
+		logerr("can't find map entry for (%lu,%lu)",
 		    (unsigned long) pkt->dev, (unsigned long) pkt->ino);
 		pthread_setcancelstate(state, NULL);
 		return 1;
@@ -1538,7 +1485,7 @@ int handle_packet_missing_direct(struct autofs_point *ap, autofs_packet_missing_
 	if (ap->state == ST_SHUTDOWN_PENDING ||
 	    ap->state == ST_SHUTDOWN_FORCE ||
 	    ap->state == ST_SHUTDOWN) {
-		send_fail(ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, ioctlfd, pkt->wait_queue_token);
 		close(ioctlfd);
 		cache_unlock(mc);
 		pthread_setcancelstate(state, NULL);
@@ -1549,7 +1496,7 @@ int handle_packet_missing_direct(struct autofs_point *ap, autofs_packet_missing_
 	if (!mt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 		error(ap->logopt, "malloc: %s", estr);
-		send_fail(ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, ioctlfd, pkt->wait_queue_token);
 		close(ioctlfd);
 		cache_unlock(mc);
 		pthread_setcancelstate(state, NULL);
@@ -1578,7 +1525,7 @@ int handle_packet_missing_direct(struct autofs_point *ap, autofs_packet_missing_
 	status = pthread_create(&thid, &thread_attr, do_mount_direct, mt);
 	if (status) {
 		error(ap->logopt, "missing mount thread create failed");
-		send_fail(ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, ioctlfd, pkt->wait_queue_token);
 		close(ioctlfd);
 		cache_unlock(mc);
 		mount_mutex_unlock(NULL);
diff --git a/daemon/indirect.c b/daemon/indirect.c
index 02e7045..5c422c8 100644
--- a/daemon/indirect.c
+++ b/daemon/indirect.c
@@ -43,63 +43,6 @@ extern pthread_attr_t thread_attr;
 static pthread_mutex_t ma_mutex = PTHREAD_MUTEX_INITIALIZER;
 static pthread_mutex_t ea_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-static int autofs_init_indirect(struct autofs_point *ap)
-{
-	int pipefd[2], cl_flags;
-
-	if ((ap->state != ST_INIT)) {
-		/* This can happen if an autofs process is already running*/
-		error(ap->logopt, "bad state %d", ap->state);
-		return -1;
-	}
-
-	ap->pipefd = ap->kpipefd = ap->ioctlfd = -1;
-
-	/* Pipe for kernel communications */
-	if (pipe(pipefd) < 0) {
-		crit(ap->logopt,
-		     "failed to create commumication pipe for autofs path %s",
-		     ap->path);
-		free(ap->path);
-		return -1;
-	}
-
-	ap->pipefd = pipefd[0];
-	ap->kpipefd = pipefd[1];
-
-	if ((cl_flags = fcntl(ap->pipefd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->pipefd, F_SETFD, cl_flags);
-	}
-
-	if ((cl_flags = fcntl(ap->kpipefd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->kpipefd, F_SETFD, cl_flags);
-	}
-
-	/* Pipe state changes from signal handler to main loop */
-	if (pipe(ap->state_pipe) < 0) {
-		crit(ap->logopt,
-		     "failed create state pipe for autofs path %s", ap->path);
-		close(ap->pipefd);
-		close(ap->kpipefd);	/* Close kernel pipe end */
-		free(ap->path);
-		return -1;
-	}
-
-	if ((cl_flags = fcntl(ap->state_pipe[0], F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->state_pipe[0], F_SETFD, cl_flags);
-	}
-
-	if ((cl_flags = fcntl(ap->state_pipe[1], F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->state_pipe[1], F_SETFD, cl_flags);
-	}
-
-	return 0;
-}
-
 static int unlink_mount_tree(struct autofs_point *ap, struct mnt_list *mnts)
 {
 	struct mnt_list *this;
@@ -118,7 +61,7 @@ static int unlink_mount_tree(struct autofs_point *ap, struct mnt_list *mnts)
 		}
 
 		if (strcmp(this->fs_type, "autofs"))
-			rv = spawn_umount(log_debug, "-l", this->path, NULL);
+			rv = spawn_umount(ap->logopt, "-l", this->path, NULL);
 		else
 			rv = umount2(this->path, MNT_DETACH);
 		if (rv == -1) {
@@ -222,12 +165,14 @@ static int do_mount_autofs_indirect(struct autofs_point *ap)
 	ioctl(ap->ioctlfd, AUTOFS_IOC_SETTIMEOUT, &timeout);
 
 	if (ap->exp_timeout)
-		msg("mounted indirect mount on %s "
+		info(ap->logopt,
+		    "mounted indirect mount on %s "
 		    "with timeout %u, freq %u seconds", ap->path,
-	 	   (unsigned int) ap->exp_timeout,
-		   (unsigned int) ap->exp_runfreq);
+	 	    (unsigned int) ap->exp_timeout,
+		    (unsigned int) ap->exp_runfreq);
 	else
-		msg("mounted indirect mount on %s with timeouts disabled",
+		info(ap->logopt,
+		    "mounted indirect mount on %s with timeouts disabled",
 		    ap->path);
 
 	fstat(ap->ioctlfd, &st);
@@ -257,9 +202,6 @@ int mount_autofs_indirect(struct autofs_point *ap)
 	int status;
 	int map;
 
-        if (autofs_init_indirect(ap))
-		return -1;
-
 	/* TODO: read map, determine map type is OK */
 	if (lookup_nss_read_map(ap, NULL, now))
 		lookup_prune_cache(ap, now);
@@ -309,7 +251,7 @@ int umount_autofs_indirect(struct autofs_point *ap)
 	rv = ioctl(ap->ioctlfd, AUTOFS_IOC_ASKUMOUNT, &ret);
 	if (rv == -1) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, "ioctl failed: %s", estr);
+		logerr("ioctl failed: %s", estr);
 		return 1;
 	} else if (!ret) {
 		error(ap->logopt, "ask umount returned busy %s", ap->path);
@@ -370,9 +312,9 @@ force_umount:
 		     "forcing umount of indirect mount %s", ap->path);
 		rv = umount2(ap->path, MNT_DETACH);
 	} else {
-		msg("umounted indirect mount %s", ap->path);
+		info(ap->logopt, "umounted indirect mount %s", ap->path);
 		if (ap->submount)
-			rm_unwanted(ap->path, 1, ap->dev);
+			rm_unwanted(ap->logopt, ap->path, 1, ap->dev);
 	}
 
 	return rv;
@@ -390,7 +332,7 @@ static int expire_indirect(struct autofs_point *ap, int ioctlfd, const char *pat
 		return 0;
 	}
 
-	retries = (count_mounts(path, st.st_dev) + 1) * EXPIRE_RETRIES;
+	retries = (count_mounts(ap->logopt, path, st.st_dev) + 1) * EXPIRE_RETRIES;
 
 	while (retries--) {
 		struct timespec tm = {0, 100000000};
@@ -559,13 +501,7 @@ void *expire_proc_indirect(void *arg)
 	 * words) the umounts are done by the time we reach here
 	 */
 	if (count)
-		debug(ap->logopt, "%d remaining in %s", count, ap->path);
-
-	/* If we are trying to shutdown make sure we can umount */
-	if (!ioctl(ap->ioctlfd, AUTOFS_IOC_ASKUMOUNT, &ret)) {
-		if (!ret)
-			msg("mount still busy %s", ap->path);
-	}
+		info(ap->logopt, "%d remaining in %s", count, ap->path);
 
 	ec.status = left;
 
@@ -590,7 +526,7 @@ static void pending_cond_destroy(void *arg)
 static void expire_send_fail(void *arg)
 {
 	struct pending_args *mt = arg;
-	send_fail(mt->ap->ioctlfd, mt->wait_queue_token);
+	send_fail(mt->ap->logopt, mt->ap->ioctlfd, mt->wait_queue_token);
 }
 
 static void free_pending_args(void *arg)
@@ -634,9 +570,9 @@ static void *do_expire_indirect(void *arg)
 	status = do_expire(mt->ap, mt->name, mt->len);
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &state);
 	if (status)
-		send_fail(ap->ioctlfd, mt->wait_queue_token);
+		send_fail(ap->logopt, ap->ioctlfd, mt->wait_queue_token);
 	else
-		send_ready(ap->ioctlfd, mt->wait_queue_token);
+		send_ready(ap->logopt, ap->ioctlfd, mt->wait_queue_token);
 	pthread_setcancelstate(state, NULL);
 
 	pthread_cleanup_pop(0);
@@ -661,8 +597,8 @@ int handle_packet_expire_indirect(struct autofs_point *ap, autofs_packet_expire_
 	mt = malloc(sizeof(struct pending_args));
 	if (!mt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, "malloc: %s", estr);
-		send_fail(ap->ioctlfd, pkt->wait_queue_token);
+		logerr("malloc: %s", estr);
+		send_fail(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
 		pthread_setcancelstate(state, NULL);
 		return 1;
 	}
@@ -684,7 +620,7 @@ int handle_packet_expire_indirect(struct autofs_point *ap, autofs_packet_expire_
 	status = pthread_create(&thid, &thread_attr, do_expire_indirect, mt);
 	if (status) {
 		error(ap->logopt, "expire thread create failed");
-		send_fail(ap->ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
 		expire_mutex_unlock(NULL);
 		pending_cond_destroy(mt);
 		free_pending_args(mt);
@@ -710,7 +646,7 @@ int handle_packet_expire_indirect(struct autofs_point *ap, autofs_packet_expire_
 static void mount_send_fail(void *arg)
 {
 	struct pending_args *mt = arg;
-	send_fail(mt->ap->ioctlfd, mt->wait_queue_token);
+	send_fail(mt->ap->logopt, mt->ap->ioctlfd, mt->wait_queue_token);
 }
 
 static void mount_mutex_unlock(void *arg)
@@ -775,7 +711,7 @@ static void *do_mount_indirect(void *arg)
 
 	pthread_setcancelstate(state, NULL);
 
-	msg("attempting to mount entry %s", buf);
+	info(ap->logopt, "attempting to mount entry %s", buf);
 
 	/*
 	 * Setup thread specific data values for macro
@@ -887,11 +823,11 @@ cont:
 	status = lookup_nss_mount(ap, NULL, mt->name, mt->len);
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &state);
 	if (status) {
-		send_ready(ap->ioctlfd, mt->wait_queue_token);
-		msg("mounted %s", buf);
+		send_ready(ap->logopt, ap->ioctlfd, mt->wait_queue_token);
+		info(ap->logopt, "mounted %s", buf);
 	} else {
-		send_fail(ap->ioctlfd, mt->wait_queue_token);
-		msg("failed to mount %s", buf);
+		send_fail(ap->logopt, ap->ioctlfd, mt->wait_queue_token);
+		info(ap->logopt, "failed to mount %s", buf);
 	}
 	pthread_setcancelstate(state, NULL);
 
@@ -918,7 +854,7 @@ int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missin
 	if (ap->state == ST_SHUTDOWN_PENDING ||
 	    ap->state == ST_SHUTDOWN_FORCE ||
 	    ap->state == ST_SHUTDOWN) {
-		send_fail(ap->ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
 		pthread_setcancelstate(state, NULL);
 		return 0;
 	}
@@ -926,8 +862,8 @@ int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missin
 	mt = malloc(sizeof(struct pending_args));
 	if (!mt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, "malloc: %s", estr);
-		send_fail(ap->ioctlfd, pkt->wait_queue_token);
+		logerr("malloc: %s", estr);
+		send_fail(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
 		pthread_setcancelstate(state, NULL);
 		return 1;
 	}
@@ -953,7 +889,7 @@ int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missin
 	status = pthread_create(&thid, &thread_attr, do_mount_indirect, mt);
 	if (status) {
 		error(ap->logopt, "expire thread create failed");
-		send_fail(ap->ioctlfd, pkt->wait_queue_token);
+		send_fail(ap->logopt, ap->ioctlfd, pkt->wait_queue_token);
 		mount_mutex_unlock(NULL);
 		pending_cond_destroy(mt);
 		free_pending_args(mt);
diff --git a/daemon/lookup.c b/daemon/lookup.c
index 4f2b318..fd99cf2 100644
--- a/daemon/lookup.c
+++ b/daemon/lookup.c
@@ -103,6 +103,7 @@ static int do_read_master(struct master *master, char *type, time_t age)
 
 static int read_master_map(struct master *master, char *type, time_t age)
 {
+	unsigned int logopt = master->logopt;
 	char *path, *save_name;
 	int result;
 
@@ -117,7 +118,7 @@ static int read_master_map(struct master *master, char *type, time_t age)
 	 */
 
 	if (strchr(master->name, '/')) {
-		error(LOGOPT_ANY, "relative path invalid in files map name");
+		error(logopt, "relative path invalid in files map name");
 		return NSS_STATUS_NOTFOUND;
 	}
 
@@ -142,6 +143,7 @@ static int read_master_map(struct master *master, char *type, time_t age)
 
 int lookup_nss_read_master(struct master *master, time_t age)
 {
+	unsigned int logopt = master->logopt;
 	struct list_head nsslist;
 	struct list_head *head, *p;
 	int result = NSS_STATUS_UNKNOWN;
@@ -149,12 +151,10 @@ int lookup_nss_read_master(struct master *master, time_t age)
 	/* If it starts with a '/' it has to be a file or LDAP map */
 	if (*master->name == '/') {
 		if (*(master->name + 1) == '/') {
-			debug(LOGOPT_NONE,
-			      "reading master ldap %s", master->name);
+			debug(logopt, "reading master ldap %s", master->name);
 			result = do_read_master(master, "ldap", age);
 		} else {
-			debug(LOGOPT_NONE,
-			      "reading master file %s", master->name);
+			debug(logopt, "reading master file %s", master->name);
 			result = do_read_master(master, "file", age);
 		}
 
@@ -184,13 +184,11 @@ int lookup_nss_read_master(struct master *master, time_t age)
 				 */
 				if (strncmp(name, "ldap", 4)) {
 					master->name = tmp + 1;
-					debug(LOGOPT_NONE,
-					      "reading master %s %s",
+					debug(logopt, "reading master %s %s",
 					      source, master->name);
 				} else {
 					master->name = name;
-					debug(LOGOPT_NONE,
-					      "reading master %s %s",
+					debug(logopt, "reading master %s %s",
 					      source, tmp + 1);
 				}
 
@@ -208,7 +206,7 @@ int lookup_nss_read_master(struct master *master, time_t age)
 	if (result) {
 		if (!list_empty(&nsslist))
 			free_sources(&nsslist);
-		error(LOGOPT_ANY, "can't to read name service switch config.");
+		error(logopt, "can't to read name service switch config.");
 		return 0;
 	}
 
@@ -220,13 +218,12 @@ int lookup_nss_read_master(struct master *master, time_t age)
 
 		this = list_entry(p, struct nss_source, list);
 
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      "reading master %s %s", this->source, master->name);
 
 		result = read_master_map(master, this->source, age);
 		if (result == NSS_STATUS_UNKNOWN) {
-			debug(LOGOPT_NONE,
-			      "no map - continuing to next source");
+			debug(logopt, "no map - continuing to next source");
 			continue;
 		}
 
@@ -1008,9 +1005,10 @@ int lookup_prune_cache(struct autofs_point *ap, time_t age)
 				if (this->ioctlfd == -1)
 					status = cache_delete(mc, key);
 				if (status != CHE_FAIL) {
-					if (ap->type == LKP_INDIRECT)
-						rmdir_path(ap, path, ap->dev);
-					else
+					if (ap->type == LKP_INDIRECT) {
+						if (ap->ghost)
+							rmdir_path(ap, path, ap->dev);
+					} else
 						rmdir_path(ap, path, this->dev);
 				}
 			}
diff --git a/daemon/module.c b/daemon/module.c
index e83c929..36eca00 100644
--- a/daemon/module.c
+++ b/daemon/module.c
@@ -33,7 +33,7 @@ int load_autofs4_module(void)
 	 */
 	fp = fopen("/proc/filesystems", "r");
 	if (!fp) {
-		error(LOGOPT_ANY, "cannot open /proc/filesystems\n");
+		logerr("cannot open /proc/filesystems\n");
 		return 0;
 	}
 
@@ -45,7 +45,7 @@ int load_autofs4_module(void)
 	}
 	fclose(fp);
 
-	ret = spawnl(log_debug, PATH_MODPROBE, PATH_MODPROBE,
+	ret = spawnl(LOGOPT_NONE, PATH_MODPROBE, PATH_MODPROBE,
 				"-q", FS_MODULE_NAME, NULL);
 	if (ret)
 		return 0;
@@ -72,7 +72,7 @@ struct lookup_mod *open_lookup(const char *name, const char *err_prefix,
 	if (!mod) {
 		if (err_prefix) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, "%s%s", err_prefix, estr);
+			logerr("%s%s", err_prefix, estr);
 		}
 		return NULL;
 	}
@@ -83,7 +83,7 @@ struct lookup_mod *open_lookup(const char *name, const char *err_prefix,
 		free(mod);
 		if (err_prefix) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, "%s%s", err_prefix, estr);
+			logerr("%s%s", err_prefix, estr);
 		}
 		return NULL;
 	}
@@ -91,7 +91,7 @@ struct lookup_mod *open_lookup(const char *name, const char *err_prefix,
 
 	if (!(dh = dlopen(fnbuf, RTLD_NOW))) {
 		if (err_prefix)
-			crit(LOGOPT_ANY, "%scannot open lookup module %s (%s)",
+			logerr("%scannot open lookup module %s (%s)",
 			       err_prefix, name, dlerror());
 		free(mod);
 		return NULL;
@@ -100,8 +100,7 @@ struct lookup_mod *open_lookup(const char *name, const char *err_prefix,
 	if (!(ver = (int *) dlsym(dh, "lookup_version"))
 	    || *ver != AUTOFS_LOOKUP_VERSION) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%slookup module %s version mismatch",
+			logerr("%slookup module %s version mismatch",
 			     err_prefix, name);
 		dlclose(dh);
 		free(mod);
@@ -114,7 +113,7 @@ struct lookup_mod *open_lookup(const char *name, const char *err_prefix,
 	    !(mod->lookup_mount = (lookup_mount_t) dlsym(dh, "lookup_mount")) ||
 	    !(mod->lookup_done = (lookup_done_t) dlsym(dh, "lookup_done"))) {
 		if (err_prefix)
-			crit(LOGOPT_ANY, "%slookup module %s corrupt", err_prefix, name);
+			logerr("%slookup module %s corrupt", err_prefix, name);
 		dlclose(dh);
 		free(mod);
 		return NULL;
@@ -156,7 +155,7 @@ struct parse_mod *open_parse(const char *name, const char *err_prefix,
 	if (!mod) {
 		if (err_prefix) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, "%s%s", err_prefix, estr);
+			logerr("%s%s", err_prefix, estr);
 		}
 		return NULL;
 	}
@@ -167,7 +166,7 @@ struct parse_mod *open_parse(const char *name, const char *err_prefix,
 		free(mod);
 		if (err_prefix) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, "%s%s", err_prefix, estr);
+			logerr("%s%s", err_prefix, estr);
 		}
 		return NULL;
 	}
@@ -175,8 +174,7 @@ struct parse_mod *open_parse(const char *name, const char *err_prefix,
 
 	if (!(dh = dlopen(fnbuf, RTLD_NOW))) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%scannot open parse module %s (%s)",
+			logerr("%scannot open parse module %s (%s)",
 			     err_prefix, name, dlerror());
 		free(mod);
 		return NULL;
@@ -185,8 +183,7 @@ struct parse_mod *open_parse(const char *name, const char *err_prefix,
 	if (!(ver = (int *) dlsym(dh, "parse_version"))
 	    || *ver != AUTOFS_PARSE_VERSION) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%sparse module %s version mismatch",
+			logerr("%sparse module %s version mismatch",
 			     err_prefix, name);
 		dlclose(dh);
 		free(mod);
@@ -197,8 +194,7 @@ struct parse_mod *open_parse(const char *name, const char *err_prefix,
 	    !(mod->parse_mount = (parse_mount_t) dlsym(dh, "parse_mount")) ||
 	    !(mod->parse_done = (parse_done_t) dlsym(dh, "parse_done"))) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%sparse module %s corrupt",
+			logerr("%sparse module %s corrupt",
 			     err_prefix, name);
 		dlclose(dh);
 		free(mod);
@@ -240,7 +236,7 @@ struct mount_mod *open_mount(const char *name, const char *err_prefix)
 	if (!mod) {
 		if (err_prefix) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, "%s%s", err_prefix, estr);
+			logerr("%s%s", err_prefix, estr);
 		}
 		return NULL;
 	}
@@ -251,7 +247,7 @@ struct mount_mod *open_mount(const char *name, const char *err_prefix)
 		free(mod);
 		if (err_prefix) {
 			char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, "%s%s", err_prefix, estr);
+			logerr("%s%s", err_prefix, estr);
 		}
 		return NULL;
 	}
@@ -259,8 +255,7 @@ struct mount_mod *open_mount(const char *name, const char *err_prefix)
 
 	if (!(dh = dlopen(fnbuf, RTLD_NOW))) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%scannot open mount module %s (%s)",
+			logerr("%scannot open mount module %s (%s)",
 			     err_prefix, name, dlerror());
 		free(mod);
 		return NULL;
@@ -269,8 +264,7 @@ struct mount_mod *open_mount(const char *name, const char *err_prefix)
 	if (!(ver = (int *) dlsym(dh, "mount_version"))
 	    || *ver != AUTOFS_MOUNT_VERSION) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%smount module %s version mismatch",
+			logerr("%smount module %s version mismatch",
 			     err_prefix, name);
 		dlclose(dh);
 		free(mod);
@@ -281,8 +275,7 @@ struct mount_mod *open_mount(const char *name, const char *err_prefix)
 	    !(mod->mount_mount = (mount_mount_t) dlsym(dh, "mount_mount")) ||
 	    !(mod->mount_done = (mount_done_t) dlsym(dh, "mount_done"))) {
 		if (err_prefix)
-			crit(LOGOPT_ANY,
-			     "%smount module %s corrupt",
+			logerr("%smount module %s corrupt",
 			     err_prefix, name);
 		dlclose(dh);
 		free(mod);
diff --git a/daemon/spawn.c b/daemon/spawn.c
index 271d37e..3d5ea56 100644
--- a/daemon/spawn.c
+++ b/daemon/spawn.c
@@ -88,7 +88,7 @@ void reset_signals(void)
 
 #define ERRBUFSIZ 2047		/* Max length of error string excl \0 */
 
-static int do_spawn(logger *log, unsigned int options, const char *prog, const char *const *argv)
+static int do_spawn(unsigned logopt, unsigned int options, const char *prog, const char *const *argv)
 {
 	pid_t f;
 	int ret, status, pipefd[2];
@@ -195,7 +195,7 @@ static int do_spawn(logger *log, unsigned int options, const char *prog, const c
 				while (errp && (p = memchr(sp, '\n', errp))) {
 					*p++ = '\0';
 					if (sp[0])	/* Don't output empty lines */
-						log(LOGOPT_ANY, ">> %s", sp);
+						warn(logopt, ">> %s", sp);
 					errp -= (p - sp);
 					sp = p;
 				}
@@ -206,7 +206,7 @@ static int do_spawn(logger *log, unsigned int options, const char *prog, const c
 				if (errp >= ERRBUFSIZ) {
 					/* Line too long, split */
 					errbuf[errp] = '\0';
-					log(LOGOPT_ANY, ">> %s", errbuf);
+					warn(logopt, ">> %s", errbuf);
 					errp = 0;
 				}
 			}
@@ -217,7 +217,7 @@ static int do_spawn(logger *log, unsigned int options, const char *prog, const c
 		if (errp > 0) {
 			/* End of file without \n */
 			errbuf[errp] = '\0';
-			log(LOGOPT_ANY, ">> %s", errbuf);
+			warn(logopt, ">> %s", errbuf);
 		}
 
 		if (waitpid(f, &ret, 0) != f)
@@ -235,12 +235,12 @@ static int do_spawn(logger *log, unsigned int options, const char *prog, const c
 	}
 }
 
-int spawnv(logger *log, const char *prog, const char *const *argv)
+int spawnv(unsigned logopt, const char *prog, const char *const *argv)
 {
-	return do_spawn(log, SPAWN_OPT_NONE, prog, argv);
+	return do_spawn(logopt, SPAWN_OPT_NONE, prog, argv);
 }
 
-int spawnl(logger *log, const char *prog, ...)
+int spawnl(unsigned logopt, const char *prog, ...)
 {
 	va_list arg;
 	int argc;
@@ -258,10 +258,10 @@ int spawnl(logger *log, const char *prog, ...)
 	while ((*p++ = va_arg(arg, char *)));
 	va_end(arg);
 
-	return do_spawn(log, SPAWN_OPT_NONE, prog, (const char **) argv);
+	return do_spawn(logopt, SPAWN_OPT_NONE, prog, (const char **) argv);
 }
 
-int spawn_mount(logger *log, ...)
+int spawn_mount(unsigned logopt, ...)
 {
 	va_list arg;
 	int argc;
@@ -279,7 +279,7 @@ int spawn_mount(logger *log, ...)
 	options = SPAWN_OPT_NONE;
 #endif
 
-	va_start(arg, log);
+	va_start(arg, logopt);
 	for (argc = 1; va_arg(arg, char *); argc++);
 	va_end(arg);
 
@@ -288,13 +288,13 @@ int spawn_mount(logger *log, ...)
 
 	argv[0] = arg0;
 
-	va_start(arg, log);
+	va_start(arg, logopt);
 	p = argv + 1;
 	while ((*p++ = va_arg(arg, char *)));
 	va_end(arg);
 
 	while (retries--) {
-		ret = do_spawn(log, options, prog, (const char **) argv);
+		ret = do_spawn(logopt, options, prog, (const char **) argv);
 		if (ret & MTAB_NOTUPDATED)
 			continue;
 		break;
@@ -311,7 +311,7 @@ int spawn_mount(logger *log, ...)
  * NOTE: If mount locking is enabled this type of recursive mount cannot
  *	 work.
  */
-int spawn_bind_mount(logger *log, ...)
+int spawn_bind_mount(unsigned logopt, ...)
 {
 	va_list arg;
 	int argc;
@@ -330,7 +330,7 @@ int spawn_bind_mount(logger *log, ...)
 	options = SPAWN_OPT_ACCESS;
 #endif
 
-	va_start(arg, log);
+	va_start(arg, logopt);
 	for (argc = 1; va_arg(arg, char *); argc++);
 	va_end(arg);
 
@@ -340,13 +340,13 @@ int spawn_bind_mount(logger *log, ...)
 	argv[0] = arg0;
 	argv[1] = bind;
 
-	va_start(arg, log);
+	va_start(arg, logopt);
 	p = argv + 2;
 	while ((*p++ = va_arg(arg, char *)));
 	va_end(arg);
 
 	while (retries--) {
-		ret = do_spawn(log, options, prog, (const char **) argv);
+		ret = do_spawn(logopt, options, prog, (const char **) argv);
 		if (ret & MTAB_NOTUPDATED)
 			continue;
 		break;
@@ -355,7 +355,7 @@ int spawn_bind_mount(logger *log, ...)
 	return ret;
 }
 
-int spawn_umount(logger *log, ...)
+int spawn_umount(unsigned logopt, ...)
 {
 	va_list arg;
 	int argc;
@@ -372,7 +372,7 @@ int spawn_umount(logger *log, ...)
 	options = SPAWN_OPT_NONE;
 #endif
 
-	va_start(arg, log);
+	va_start(arg, logopt);
 	for (argc = 1; va_arg(arg, char *); argc++);
 	va_end(arg);
 
@@ -381,13 +381,13 @@ int spawn_umount(logger *log, ...)
 
 	argv[0] = arg0;
 
-	va_start(arg, log);
+	va_start(arg, logopt);
 	p = argv + 1;
 	while ((*p++ = va_arg(arg, char *)));
 	va_end(arg);
 
 	while (retries--) {
-		ret = do_spawn(log, options, prog, (const char **) argv);
+		ret = do_spawn(logopt, options, prog, (const char **) argv);
 		if (ret & MTAB_NOTUPDATED)
 			continue;
 		break;
diff --git a/daemon/state.c b/daemon/state.c
index 39f4497..a2da762 100644
--- a/daemon/state.c
+++ b/daemon/state.c
@@ -58,22 +58,20 @@ void dump_state_queue(void)
 	struct list_head *head = &state_queue;
 	struct list_head *p, *q;
 
-	debug(LOGOPT_ANY, "dumping queue");
+	logmsg("dumping queue");
 
 	list_for_each(p, head) {
 		struct state_queue *entry;
 
 		entry = list_entry(p, struct state_queue, list);
-		debug(LOGOPT_ANY,
-		      "queue list head path %s state %d busy %d",
+		logmsg("queue list head path %s state %d busy %d",
 		      entry->ap->path, entry->state, entry->busy);
 
 		list_for_each(q, &entry->pending) {
 			struct state_queue *this;
 
 			this = list_entry(q, struct state_queue, pending);
-			debug(LOGOPT_ANY,
-			      "queue list entry path %s state %d busy %d",
+			logmsg("queue list entry path %s state %d busy %d",
 			      this->ap->path, this->state, this->busy);
 		}
 	}
@@ -85,7 +83,7 @@ void nextstate(int statefd, enum states next)
 
 	if (write(statefd, &next, sizeof(next)) != sizeof(next)) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(LOGOPT_ANY, "write failed %s", estr);
+		logerr("write failed %s", estr);
 	}
 }
 
diff --git a/include/automount.h b/include/automount.h
index d55ba5c..37a3c0a 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -131,6 +131,7 @@ struct mapent_cache {
 	unsigned int size;
 	pthread_mutex_t ino_index_mutex;
 	struct list_head *ino_index;
+	struct autofs_point *ap;
 	struct map_source *map;
 	struct mapent **hash;
 };
@@ -164,7 +165,7 @@ void cache_readlock(struct mapent_cache *mc);
 void cache_writelock(struct mapent_cache *mc);
 int cache_try_writelock(struct mapent_cache *mc);
 void cache_unlock(struct mapent_cache *mc);
-struct mapent_cache *cache_init(struct map_source *map);
+struct mapent_cache *cache_init(struct autofs_point *ap, struct map_source *map);
 struct mapent_cache *cache_init_null_cache(struct master *master);
 int cache_set_ino_index(struct mapent_cache *mc, const char *key, dev_t dev, ino_t ino);
 /* void cache_set_ino(struct mapent *me, dev_t dev, ino_t ino); */
@@ -200,11 +201,11 @@ int free_argv(int argc, const char **argv);
 inline void dump_core(void);
 int aquire_lock(void);
 void release_lock(void);
-int spawnl(logger *log, const char *prog, ...);
-int spawnv(logger *log, const char *prog, const char *const *argv);
-int spawn_mount(logger *log, ...);
-int spawn_bind_mount(logger *log, ...);
-int spawn_umount(logger *log, ...);
+int spawnl(unsigned logopt, const char *prog, ...);
+int spawnv(unsigned logopt, const char *prog, const char *const *argv);
+int spawn_mount(unsigned logopt, ...);
+int spawn_bind_mount(unsigned logopt, ...);
+int spawn_umount(unsigned logopt, ...);
 void reset_signals(void);
 int do_mount(struct autofs_point *ap, const char *root, const char *name,
 	     int name_len, const char *what, const char *fstype,
@@ -222,6 +223,8 @@ int rmdir_path(struct autofs_point *ap, const char *path, dev_t dev);
 #define MAPENT_MAX_LEN 4095
 #define PARSE_MAX_BUF	KEY_MAX_LEN + MAPENT_MAX_LEN + 2
 
+#define AUTOFS_LOGPRI_FIFO "/tmp/autofs.fifo"
+
 int lookup_nss_read_master(struct master *master, time_t age);
 int lookup_nss_read_map(struct autofs_point *ap, struct map_source *source, time_t age);
 int lookup_enumerate(struct autofs_point *ap,
@@ -435,6 +438,7 @@ struct autofs_point {
 	int pipefd;			/* File descriptor for pipe */
 	int kpipefd;			/* Kernel end descriptor for pipe */
 	int ioctlfd;			/* File descriptor for ioctls */
+	int logpri_fifo;		/* FIFO used for changing log levels */
 	dev_t dev;			/* "Device" number assigned by kernel */
 	struct master_mapent *entry;	/* Master map entry for this mount */
 	unsigned int type;		/* Type of map direct or indirect */
@@ -464,8 +468,8 @@ struct autofs_point {
 
 void *handle_mounts(void *arg);
 int umount_multi(struct autofs_point *ap, const char *path, int incl);
-int send_ready(int ioctlfd, unsigned int wait_queue_token);
-int send_fail(int ioctlfd, unsigned int wait_queue_token);
+int send_ready(unsigned logopt, int ioctlfd, unsigned int wait_queue_token);
+int send_fail(unsigned logopt, int ioctlfd, unsigned int wait_queue_token);
 int do_expire(struct autofs_point *ap, const char *name, int namelen);
 void *expire_proc_indirect(void *);
 void *expire_proc_direct(void *);
@@ -483,8 +487,8 @@ int handle_packet_expire_indirect(struct autofs_point *ap, autofs_packet_expire_
 int handle_packet_expire_direct(struct autofs_point *ap, autofs_packet_expire_direct_t *pkt);
 int handle_packet_missing_indirect(struct autofs_point *ap, autofs_packet_missing_indirect_t *pkt);
 int handle_packet_missing_direct(struct autofs_point *ap, autofs_packet_missing_direct_t *pkt);
-void rm_unwanted(const char *path, int incl, dev_t dev);
-int count_mounts(const char *path, dev_t dev);
+void rm_unwanted(unsigned logopt, const char *path, int incl, dev_t dev);
+int count_mounts(unsigned logopt, const char *path, dev_t dev);
 
 #define state_mutex_lock(ap) \
 do { \
diff --git a/include/log.h b/include/log.h
index 3276cca..6a4a942 100644
--- a/include/log.h
+++ b/include/log.h
@@ -20,6 +20,7 @@
 /* Define logging functions */
 
 #define LOGOPT_NONE	0x0000
+#define LOGOPT_ERROR	0x0000
 #define LOGOPT_DEBUG	0x0001
 #define LOGOPT_VERBOSE	0x0002
 #define LOGOPT_ANY	(LOGOPT_DEBUG | LOGOPT_VERBOSE)
@@ -29,34 +30,33 @@ struct autofs_point;
 extern void set_log_norm(void);
 extern void set_log_verbose(void);
 extern void set_log_debug(void);
-extern void set_mnt_logging(struct autofs_point *);
+extern void set_log_norm_ap(struct autofs_point *ap);
+extern void set_log_verbose_ap(struct autofs_point *ap);
+extern void set_log_debug_ap(struct autofs_point *ap);
+extern void set_mnt_logging(unsigned global_logopt);
 
 extern void log_to_syslog(void);
 extern void log_to_stderr(void);
  
-typedef void logger(unsigned int logopt, const char* msg, ...);
-
-extern void (*log_info)(unsigned int, const char* msg, ...);
-extern void (*log_notice)(unsigned int, const char* msg, ...);
-extern void (*log_warn)(unsigned int, const char* msg, ...);
-extern void (*log_error)(unsigned int, const char* msg, ...);
-extern void (*log_crit)(unsigned int, const char* msg, ...);
-extern void (*log_debug)(unsigned int, const char* msg, ...);
-
-#define msg(msg, args...)	\
-	do { log_info(LOGOPT_NONE, msg, ##args); } while (0)
+extern void log_info(unsigned int, const char* msg, ...);
+extern void log_notice(unsigned int, const char* msg, ...);
+extern void log_warn(unsigned int, const char* msg, ...);
+extern void log_error(unsigned, const char* msg, ...);
+extern void log_crit(unsigned, const char* msg, ...);
+extern void log_debug(unsigned int, const char* msg, ...);
+extern void logmsg(const char* msg, ...);
 
 #define debug(opt, msg, args...)	\
 	do { log_debug(opt, "%s: " msg,  __FUNCTION__, ##args); } while (0)
 
-#define info(opt, msg, args...)	\
-	do { log_info(opt, "%s: " msg,  __FUNCTION__, ##args); } while (0)
+#define info(opt, msg, args...)		\
+	do { log_info(opt, msg,  ##args); } while (0)
 
 #define notice(opt, msg, args...)	\
-	do { log_notice(opt, "%s: " msg,  __FUNCTION__, ##args); } while (0)
+	do { log_notice(opt, msg, ##args); } while (0)
 
-#define warn(opt, msg, args...)	\
-	do { log_warn(opt, "%s: " msg,  __FUNCTION__, ##args); } while (0)
+#define warn(opt, msg, args...)		\
+	do { log_warn(opt, msg, ##args); } while (0)
 
 #define error(opt, msg, args...)	\
 	do { log_error(opt, "%s: " msg,  __FUNCTION__, ##args); } while (0)
@@ -64,17 +64,18 @@ extern void (*log_debug)(unsigned int, const char* msg, ...);
 #define crit(opt, msg, args...)	\
 	do { log_crit(opt, "%s: " msg,  __FUNCTION__, ##args); } while (0)
 
+#define logerr(msg, args...)	\
+	do { logmsg("%s:%d: " msg, __FUNCTION__, __LINE__, ##args); } while (0)
+
 #define fatal(status)						    \
 	do {							    \
 		if (status == EDEADLK) {			    \
-			log_crit(LOGOPT_ANY,			    \
-				 "%s: deadlock detected "	    \
+			logmsg("deadlock detected "		    \
 				 "at line %d in %s, dumping core.", \
-				 __FUNCTION__, __LINE__, __FILE__); \
+				  __LINE__, __FILE__);		    \
 			dump_core();				    \
 		}						    \
-		log_crit(LOGOPT_ANY,				    \
-			 "unexpected pthreads error: %d at %d "	    \
+		logmsg("unexpected pthreads error: %d at %d "	    \
 			 "in %s", status, __LINE__, __FILE__);	    \
 		abort();					    \
 	} while(0)
@@ -83,7 +84,7 @@ extern void (*log_debug)(unsigned int, const char* msg, ...);
 #define assert(x)							\
 do {									\
 	if (!(x)) {							\
-		log_crit(LOGOPT_ANY, __FILE__				\
+		logmsg(__FILE__					\
 			 ":%d: assertion failed: " #x, __LINE__);	\
 	}								\
 } while(0)
diff --git a/include/lookup_ldap.h b/include/lookup_ldap.h
index ca8d658..5b5c475 100644
--- a/include/lookup_ldap.h
+++ b/include/lookup_ldap.h
@@ -94,13 +94,13 @@ struct lookup_context {
 #define LDAP_AUTH_AUTODETECT	0x0004
 
 /* lookup_ldap.c */
-LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt);
-int unbind_ldap_connection(LDAP *ldap, struct lookup_context *ctxt);
+LDAP *init_ldap_connection(unsigned logopt, const char *uri, struct lookup_context *ctxt);
+int unbind_ldap_connection(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt);
 int authtype_requires_creds(const char *authtype);
 
 /* cyrus-sasl.c */
-int autofs_sasl_init(LDAP *ldap, struct lookup_context *ctxt);
-int autofs_sasl_bind(LDAP *ldap, struct lookup_context *ctxt);
+int autofs_sasl_init(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt);
+int autofs_sasl_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt);
 void autofs_sasl_unbind(struct lookup_context *ctxt);
 void autofs_sasl_done(struct lookup_context *ctxt);
 #endif
diff --git a/include/master.h b/include/master.h
index 8470bb1..5f10d1f 100644
--- a/include/master.h
+++ b/include/master.h
@@ -62,6 +62,7 @@ struct master {
 	unsigned int default_ghost;
 	unsigned int default_logging;
 	unsigned int default_timeout;
+	unsigned int logopt;
 	struct mapent_cache *nc;
 	struct list_head mounts;
 };
@@ -106,6 +107,7 @@ int master_notify_submount(struct autofs_point *, const char *path, enum states)
 void master_signal_submount(struct autofs_point *, unsigned int);
 void master_notify_state_change(struct master *, int);
 int master_mount_mounts(struct master *, time_t, int);
+extern inline unsigned int master_get_logopt(void);
 int master_list_empty(struct master *);
 int master_kill(struct master *);
 
diff --git a/include/replicated.h b/include/replicated.h
index 3afe9f7..672f853 100644
--- a/include/replicated.h
+++ b/include/replicated.h
@@ -62,8 +62,8 @@ struct host {
 
 void seed_random(void);
 void free_host_list(struct host **);
-int parse_location(struct host **, const char *);
-int prune_host_list(struct host **, unsigned int, const char *, unsigned int);
+int parse_location(unsigned, struct host **, const char *);
+int prune_host_list(unsigned, struct host **, unsigned int, const char *, unsigned int);
 void dump_host_list(struct host *);
 
 #endif
diff --git a/lib/alarm.c b/lib/alarm.c
index 90bf7aa..6a70ed1 100755
--- a/lib/alarm.c
+++ b/lib/alarm.c
@@ -51,7 +51,7 @@ void dump_alarms(void)
 		struct alarm *this;
 
 		this = list_entry(p, struct alarm, list);
-		msg("alarm time = %d", this->time);
+		logmsg("alarm time = %d", this->time);
 	}
 	pthread_mutex_unlock(&mutex);
 }
diff --git a/lib/args.c b/lib/args.c
index fbfb004..9616598 100644
--- a/lib/args.c
+++ b/lib/args.c
@@ -37,7 +37,7 @@ char **add_argv(int argc, char **argv, char *str)
 		if (argv[i]) {
 			vector[i] = strdup(argv[i]);
 			if (!vector[i]) {
-				error(LOGOPT_ANY, "failed to strdup arg");
+				logerr("failed to strdup arg");
 				break;
 			}
 		} else
@@ -81,7 +81,7 @@ char **append_argv(int argc1, char **argv1, int argc2, char **argv2)
 		if (argv2[j]) {
 			vector[i] = strdup(argv2[j]);
 			if (!vector[i]) {
-				error(LOGOPT_ANY, "failed to strdup arg");
+				logerr("failed to strdup arg");
 				break;
 			}
 		} else
@@ -116,7 +116,7 @@ const char **copy_argv(int argc, const char **argv)
 		if (argv[i]) {
 			vector[i] = strdup(argv[i]);
 			if (!vector[i]) {
-				error(LOGOPT_ANY, "failed to strdup arg");
+				logerr("failed to strdup arg");
 				break;
 			}
 		} else
diff --git a/lib/cache.c b/lib/cache.c
index 06bb461..55586a3 100644
--- a/lib/cache.c
+++ b/lib/cache.c
@@ -34,7 +34,7 @@ void cache_dump_multi(struct list_head *list)
 
 	list_for_each(p, list) {
 		me = list_entry(p, struct mapent, multi_list);
-		msg("key=%s", me->key);
+		logmsg("key=%s", me->key);
 	}
 }
 
@@ -48,7 +48,7 @@ void cache_dump_cache(struct mapent_cache *mc)
 		if (me == NULL)
 			continue;
 		while (me) {
-			msg("me->key=%s me->multi=%p dev=%ld ino=%ld",
+			logmsg("me->key=%s me->multi=%p dev=%ld ino=%ld",
 				me->key, me->multi, me->dev, me->ino);
 			me = me->next;
 		}
@@ -61,7 +61,7 @@ void cache_readlock(struct mapent_cache *mc)
 
 	status = pthread_rwlock_rdlock(&mc->rwlock);
 	if (status) {
-		error(LOGOPT_ANY, "mapent cache rwlock lock failed");
+		logmsg("mapent cache rwlock lock failed");
 		fatal(status);
 	}
 	return;
@@ -73,7 +73,7 @@ void cache_writelock(struct mapent_cache *mc)
 
 	status = pthread_rwlock_wrlock(&mc->rwlock);
 	if (status) {
-		error(LOGOPT_ANY, "mapent cache rwlock lock failed");
+		logmsg("mapent cache rwlock lock failed");
 		fatal(status);
 	}
 	return;
@@ -85,7 +85,7 @@ int cache_try_writelock(struct mapent_cache *mc)
 
 	status = pthread_rwlock_trywrlock(&mc->rwlock);
 	if (status) {
-		debug(LOGOPT_ANY, "mapent cache rwlock busy");
+		logmsg("mapent cache rwlock busy");
 		return 0;
 	}
 	return 1;
@@ -97,7 +97,7 @@ void cache_unlock(struct mapent_cache *mc)
 
 	status = pthread_rwlock_unlock(&mc->rwlock);
 	if (status) {
-		error(LOGOPT_ANY, "mapent cache rwlock unlock failed");
+		logmsg("mapent cache rwlock unlock failed");
 		fatal(status);
 	}
 	return;
@@ -120,7 +120,7 @@ void cache_multi_lock(struct mapent *me)
 
 	status = pthread_mutex_lock(&me->multi_mutex);
 	if (status) {
-		error(LOGOPT_ANY, "mapent cache multi mutex lock failed");
+		logmsg("mapent cache multi mutex lock failed");
 		fatal(status);
 	}
 	return;
@@ -135,7 +135,7 @@ void cache_multi_unlock(struct mapent *me)
 
 	status = pthread_mutex_unlock(&me->multi_mutex);
 	if (status) {
-		error(LOGOPT_ANY, "mapent cache multi mutex unlock failed");
+		logmsg("mapent cache multi mutex unlock failed");
 		fatal(status);
 	}
 	return;
@@ -164,7 +164,7 @@ static inline void ino_index_unlock(struct mapent_cache *mc)
 	return;
 }
 
-struct mapent_cache *cache_init(struct map_source *map)
+struct mapent_cache *cache_init(struct autofs_point *ap, struct map_source *map)
 {
 	struct mapent_cache *mc;
 	unsigned int i;
@@ -207,6 +207,7 @@ struct mapent_cache *cache_init(struct map_source *map)
 		INIT_LIST_HEAD(&mc->ino_index[i]);
 	}
 
+	mc->ap = ap;
 	mc->map = map;
 
 	cache_unlock(mc);
@@ -257,6 +258,9 @@ struct mapent_cache *cache_init_null_cache(struct master *master)
 		INIT_LIST_HEAD(&mc->ino_index[i]);
 	}
 
+	mc->ap = NULL;
+	mc->map = NULL;
+
 	cache_unlock(mc);
 
 	return mc;
@@ -608,6 +612,7 @@ static void cache_add_ordered_offset(struct mapent *me, struct list_head *head)
 /* cache must be write locked by caller */
 int cache_add_offset(struct mapent_cache *mc, const char *mkey, const char *key, const char *mapent, time_t age)
 {
+	unsigned logopt = mc->ap ? mc->ap->logopt : master_get_logopt();
 	struct mapent *me, *owner;
 	int ret = CHE_OK;
 
@@ -621,7 +626,7 @@ int cache_add_offset(struct mapent_cache *mc, const char *mkey, const char *key,
 
 	ret = cache_add(mc, owner->source, key, mapent, age);
 	if (ret == CHE_FAIL) {
-		warn(LOGOPT_ANY, "failed to add key %s to cache", key);
+		warn(logopt, "failed to add key %s to cache", key);
 		return CHE_FAIL;
 	}
 
@@ -689,6 +694,7 @@ int cache_set_parents(struct mapent *mm)
 /* cache must be write locked by caller */
 int cache_update(struct mapent_cache *mc, struct map_source *ms, const char *key, const char *mapent, time_t age)
 {
+	unsigned logopt = mc->ap ? mc->ap->logopt : master_get_logopt();
 	struct mapent *me = NULL;
 	char *pent;
 	int ret = CHE_OK;
@@ -697,7 +703,7 @@ int cache_update(struct mapent_cache *mc, struct map_source *ms, const char *key
 	if (!me || (*me->key == '*' && *key != '*')) {
 		ret = cache_add(mc, ms, key, mapent, age);
 		if (!ret) {
-			debug(LOGOPT_NONE, "failed for %s", key);
+			debug(logopt, "failed for %s", key);
 			return CHE_FAIL;
 		}
 		ret = CHE_UPDATED;
@@ -796,6 +802,7 @@ done:
 /* cache must be write locked by caller */
 int cache_delete_offset_list(struct mapent_cache *mc, const char *key)
 {
+	unsigned logopt = mc->ap ? mc->ap->logopt : master_get_logopt();
 	struct mapent *me;
 	struct mapent *this;
 	struct list_head *head, *next;
@@ -816,7 +823,7 @@ int cache_delete_offset_list(struct mapent_cache *mc, const char *key)
 		this = list_entry(next, struct mapent, multi_list);
 		next = next->next;
 		if (this->ioctlfd != -1) {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      "active offset mount key %s", this->key);
 			return CHE_FAIL;
 		}
@@ -829,10 +836,10 @@ int cache_delete_offset_list(struct mapent_cache *mc, const char *key)
 		next = next->next;
 		list_del_init(&this->multi_list);
 		this->multi = NULL;
-		debug(LOGOPT_NONE, "deleting offset key %s", this->key);
+		debug(logopt, "deleting offset key %s", this->key);
 		status = cache_delete(mc, this->key);
 		if (status == CHE_FAIL) {
-			warn(LOGOPT_ANY,
+			warn(logopt,
 			     "failed to delete offset %s", this->key);
 			this->multi = me;
 			/* TODO: add list back in */
diff --git a/lib/defaults.c b/lib/defaults.c
index 2cccf20..94885e8 100644
--- a/lib/defaults.c
+++ b/lib/defaults.c
@@ -105,17 +105,22 @@ static int get_env_yesno(const char *name)
  * We've changed the key names so we need to check for the
  * config key and it's old name for backward conpatibility.
 */
-static int check_set_config_value(const char *res, const char *name, const char *value)
+static int check_set_config_value(const char *res, const char *name, const char *value, unsigned to_syslog)
 {
 	char *old_name;
 	int ret;
 
 	if (!strcasecmp(res, name)) {
 		ret = setenv(name, value, 0);
-		if (ret)
-			fprintf(stderr,
-			        "can't set config value for %s, "
-				"error %d", name, ret);
+		if (ret) {
+			if (!to_syslog)
+				fprintf(stderr,
+				        "can't set config value for %s, "
+					"error %d\n", name, ret);
+			else
+				logmsg("can't set config value for %s, "
+				      "error %d", name, ret);
+		}
 		return 1;
 	}
 
@@ -125,10 +130,15 @@ static int check_set_config_value(const char *res, const char *name, const char
 
 	if (!strcasecmp(res, old_name)) {
 		ret = setenv(name, value, 0);
-		if (ret)
-			fprintf(stderr,
-			        "can't set config value for %s, "
-				"error %d", name, ret);
+		if (ret) {
+			if (!to_syslog)
+				fprintf(stderr,
+				        "can't set config value for %s, "
+					"error %d\n", name, ret);
+			else
+				logmsg("can't set config value for %s, "
+				      "error %d\n", name, ret);
+		}
 		return 1;
 	}
 	return 0;
@@ -296,19 +306,19 @@ unsigned int defaults_read_config(unsigned int to_syslog)
 		if (!parse_line(res, &key, &value))
 			continue;
 
-		if (check_set_config_value(key, ENV_NAME_MASTER_MAP, value) ||
-		    check_set_config_value(key, ENV_NAME_TIMEOUT, value) ||
-		    check_set_config_value(key, ENV_NAME_BROWSE_MODE, value) ||
-		    check_set_config_value(key, ENV_NAME_LOGGING, value) ||
-		    check_set_config_value(key, ENV_LDAP_TIMEOUT, value) ||
-		    check_set_config_value(key, ENV_LDAP_NETWORK_TIMEOUT, value) ||
-		    check_set_config_value(key, ENV_NAME_MAP_OBJ_CLASS, value) ||
-		    check_set_config_value(key, ENV_NAME_ENTRY_OBJ_CLASS, value) ||
-		    check_set_config_value(key, ENV_NAME_MAP_ATTR, value) ||
-		    check_set_config_value(key, ENV_NAME_ENTRY_ATTR, value) ||
-		    check_set_config_value(key, ENV_NAME_VALUE_ATTR, value) ||
-		    check_set_config_value(key, ENV_APPEND_OPTIONS, value) ||
-		    check_set_config_value(key, ENV_AUTH_CONF_FILE, value))
+		if (check_set_config_value(key, ENV_NAME_MASTER_MAP, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_BROWSE_MODE, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_LOGGING, value, to_syslog) ||
+		    check_set_config_value(key, ENV_LDAP_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_LDAP_NETWORK_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_MAP_OBJ_CLASS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_ENTRY_OBJ_CLASS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_MAP_ATTR, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_ENTRY_ATTR, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_VALUE_ATTR, value, to_syslog) ||
+		    check_set_config_value(key, ENV_APPEND_OPTIONS, value, to_syslog) ||
+		    check_set_config_value(key, ENV_AUTH_CONF_FILE, value, to_syslog))
 			;
 	}
 
@@ -318,8 +328,7 @@ unsigned int defaults_read_config(unsigned int to_syslog)
 				"fgets returned error %d while reading %s\n",
 				ferror(f), DEFAULTS_CONFIG_FILE);
 		} else {
-			error(LOGOPT_ANY,
-			      "fgets returned error %d while reading %s",
+			logmsg("fgets returned error %d while reading %s",
 			      ferror(f), DEFAULTS_CONFIG_FILE);
 		}
 		fclose(f);
diff --git a/lib/log.c b/lib/log.c
index b747e12..65e8ad2 100644
--- a/lib/log.c
+++ b/lib/log.c
@@ -27,11 +27,6 @@
 
 #include "automount.h"
 
-/*
-struct syslog_data syslog_context = AUTOFS_SYSLOG_CONTEXT;
-struct syslog_data *slc = &syslog_context;
-*/
-
 static unsigned int syslog_open = 0;
 static unsigned int logging_to_syslog = 0;
 
@@ -39,32 +34,44 @@ static unsigned int logging_to_syslog = 0;
 static unsigned int do_verbose = 0;		/* Verbose feedback option */
 static unsigned int do_debug = 0;		/* Full debug output */
 
-static void null(unsigned int logopt, const char *msg, ...) { }
-
-void (*log_info)(unsigned int logopt, const char* msg, ...) = null;
-void (*log_notice)(unsigned int logopt, const char* msg, ...) = null;
-void (*log_warn)(unsigned int logopt, const char* msg, ...) = null;
-void (*log_error)(unsigned int logopt, const char* msg, ...) = null;
-void (*log_crit)(unsigned int logopt, const char* msg, ...) = null;
-void (*log_debug)(unsigned int logopt, const char* msg, ...) = null;
-
 void set_log_norm(void)
 {
 	do_verbose = 0;
 	do_debug = 0;
+	return;
 }
 
 void set_log_verbose(void)
 {
 	do_verbose = 1;
+	return;
 }
 
 void set_log_debug(void)
 {
 	do_debug = 1;
+	return;
+}
+
+void set_log_norm_ap(struct autofs_point *ap)
+{
+	ap->logopt = LOGOPT_ERROR;
+	return;
+}
+
+void set_log_verbose_ap(struct autofs_point *ap)
+{
+	ap->logopt = LOGOPT_VERBOSE;
+	return;
+}
+
+void set_log_debug_ap(struct autofs_point *ap)
+{
+	ap->logopt = LOGOPT_DEBUG;
+	return;
 }
 
-static void syslog_info(unsigned int logopt, const char *msg, ...)
+void log_info(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & (LOGOPT_DEBUG | LOGOPT_VERBOSE);
 	va_list ap;
@@ -73,11 +80,18 @@ static void syslog_info(unsigned int logopt, const char *msg, ...)
 		return;
 
 	va_start(ap, msg);
-	vsyslog(LOG_INFO, msg, ap);
+	if (logging_to_syslog)
+		vsyslog(LOG_INFO, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
+	}
 	va_end(ap);
+
+	return;
 }
 
-static void syslog_notice(unsigned int logopt, const char *msg, ...)
+void log_notice(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & (LOGOPT_DEBUG | LOGOPT_VERBOSE);
 	va_list ap;
@@ -86,11 +100,18 @@ static void syslog_notice(unsigned int logopt, const char *msg, ...)
 		return;
 
 	va_start(ap, msg);
-	vsyslog(LOG_NOTICE, msg, ap);
+	if (logging_to_syslog)
+		vsyslog(LOG_NOTICE, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
+	}
 	va_end(ap);
+
+	return;
 }
 
-static void syslog_warn(unsigned int logopt, const char *msg, ...)
+void log_warn(unsigned int logopt, const char *msg, ...)
 {
 	unsigned int opt_log = logopt & (LOGOPT_DEBUG | LOGOPT_VERBOSE);
 	va_list ap;
@@ -99,70 +120,79 @@ static void syslog_warn(unsigned int logopt, const char *msg, ...)
 		return;
 
 	va_start(ap, msg);
-	vsyslog(LOG_WARNING, msg, ap);
+	if (logging_to_syslog)
+		vsyslog(LOG_WARNING, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
+	}
 	va_end(ap);
+
+	return;
 }
 
-static void syslog_err(unsigned int logopt, const char *msg, ...)
+void log_error(unsigned logopt, const char *msg, ...)
 {
 	va_list ap;
+
 	va_start(ap, msg);
-	vsyslog(LOG_ERR, msg, ap);
+	if (logging_to_syslog)
+		vsyslog(LOG_ERR, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
+	}
 	va_end(ap);
+	return;
 }
 
-static void syslog_crit(unsigned int logopt, const char *msg, ...)
+void log_crit(unsigned logopt, const char *msg, ...)
 {
 	va_list ap;
+
 	va_start(ap, msg);
-	vsyslog(LOG_CRIT, msg, ap);
+	if (logging_to_syslog)
+		vsyslog(LOG_CRIT, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
+	}
 	va_end(ap);
+	return;
 }
 
-static void syslog_debug(unsigned int logopt, const char *msg, ...)
+void log_debug(unsigned int logopt, const char *msg, ...)
 {
+	unsigned int opt_log = logopt & LOGOPT_DEBUG;
 	va_list ap;
 
-	if (!do_debug && !(logopt & LOGOPT_DEBUG))
+	if (!do_debug && !opt_log)
 		return;
 
 	va_start(ap, msg);
-	vsyslog(LOG_DEBUG, msg, ap);
+	if (logging_to_syslog)
+		vsyslog(LOG_WARNING, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
+	}
 	va_end(ap);
+
+	return;
 }
 
-static void to_stderr(unsigned int logopt, const char *msg, ...)
+void logmsg(const char *msg, ...)
 {
 	va_list ap;
 	va_start(ap, msg);
-	vfprintf(stderr, msg, ap);
-	fputc('\n',stderr);
-	va_end(ap);
-}
-
-void set_mnt_logging(struct autofs_point *ap)
-{
-	unsigned int opt_verbose = ap->logopt & LOGOPT_VERBOSE;
-	unsigned int opt_debug = ap->logopt & LOGOPT_DEBUG;
-
-	if (opt_debug) {
-		if (logging_to_syslog)
-			log_debug = syslog_debug;
-		else
-			log_debug = to_stderr;
-	}
-
-	if (opt_verbose || opt_debug) {
-		if (logging_to_syslog) {
-			log_info = syslog_info;
-			log_notice = syslog_notice;
-			log_warn = syslog_warn;
-		} else {
-			log_info = to_stderr;
-			log_notice = to_stderr;
-			log_warn = to_stderr;
-		}
+	if (logging_to_syslog)
+		vsyslog(LOG_CRIT, msg, ap);
+	else {
+		vfprintf(stderr, msg, ap);
+		fputc('\n', stderr);
 	}
+	va_end(ap);
+	return;
 }
 
 void log_to_syslog(void)
@@ -175,31 +205,13 @@ void log_to_syslog(void)
 		openlog("automount", LOG_PID, LOG_DAEMON);
 	}
 
-	if (do_debug)
-		log_debug = syslog_debug;
-	else
-		log_debug = null;
-
-	if (do_verbose || do_debug) {
-		log_info = syslog_info;
-		log_notice = syslog_notice;
-		log_warn = syslog_warn;
-	} else {
-		log_info = null;
-		log_notice = null;
-		log_warn = null;
-	}
-
-	log_error = syslog_err;
-	log_crit = syslog_crit;
-
 	logging_to_syslog = 1;
 
 	/* Redirect all our file descriptors to /dev/null */
 	nullfd = open("/dev/null", O_RDWR);
 	if (nullfd < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		syslog_crit(LOGOPT_ANY, "cannot open /dev/null: %s", estr);
+		fprintf(stderr, "cannot open /dev/null: %s", estr);
 		exit(1);
 	}
 
@@ -207,13 +219,15 @@ void log_to_syslog(void)
 	    dup2(nullfd, STDOUT_FILENO) < 0 ||
 	    dup2(nullfd, STDERR_FILENO) < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		syslog_crit(LOGOPT_ANY,
-			    "redirecting file descriptors failed: %s", estr);
+		fprintf(stderr,
+			"redirecting file descriptors failed: %s", estr);
 		exit(1);
 	}
 
 	if (nullfd > 2)
 		close(nullfd);
+
+	return;
 }
 
 void log_to_stderr(void)
@@ -223,23 +237,7 @@ void log_to_stderr(void)
 		closelog();
 	}
 
-	if (do_debug)
-		log_debug = to_stderr;
-	else
-		log_debug = null;
-
-	if (do_verbose || do_debug) {
-		log_info = to_stderr;
-		log_notice = to_stderr;
-		log_warn = to_stderr;
-	} else {
-		log_info = null;
-		log_notice = null;
-		log_warn = null;
-	}
-
-	log_error = to_stderr;
-	log_crit = to_stderr;
-
 	logging_to_syslog = 0;
+
+	return;
 }
diff --git a/lib/macros.c b/lib/macros.c
index 936ae06..fa6db8e 100644
--- a/lib/macros.c
+++ b/lib/macros.c
@@ -50,8 +50,7 @@ void dump_table(struct substvar *table)
 		fatal(status);
 
 	while (lv) {
-		debug(LOGOPT_NONE,
-		      "lv->def %s lv->val %s lv->next %p",
+		logmsg("lv->def %s lv->val %s lv->next %p",
 		      lv->def, lv->val, lv->next);
 		lv = lv->next;
 	}
diff --git a/lib/master.c b/lib/master.c
index abc3bc2..2e24ad0 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -524,8 +524,7 @@ void master_source_writelock(struct master_mapent *entry)
 
 	status = pthread_rwlock_wrlock(&entry->source_lock);
 	if (status) {
-		error(LOGOPT_ANY,
-		      "master_mapent source write lock failed");
+		logmsg("master_mapent source write lock failed");
 		fatal(status);
 	}
 	return;
@@ -537,8 +536,7 @@ void master_source_readlock(struct master_mapent *entry)
 
 	status = pthread_rwlock_rdlock(&entry->source_lock);
 	if (status) {
-		error(LOGOPT_ANY,
-		      "master_mapent source read lock failed");
+		logmsg("master_mapent source read lock failed");
 		fatal(status);
 	}
 	return;
@@ -550,8 +548,7 @@ void master_source_unlock(struct master_mapent *entry)
 
 	status = pthread_rwlock_unlock(&entry->source_lock);
 	if (status) {
-		error(LOGOPT_ANY,
-		      "master_mapent source unlock failed");
+		logmsg("master_mapent source unlock failed");
 		fatal(status);
 	}
 	return;
@@ -572,7 +569,7 @@ void master_source_current_wait(struct master_mapent *entry)
 
 	status = pthread_mutex_lock(&entry->current_mutex);
 	if (status) {
-		error(LOGOPT_ANY, "entry current source lock failed");
+		logmsg("entry current source lock failed");
 		fatal(status);
 	}
 
@@ -580,8 +577,7 @@ void master_source_current_wait(struct master_mapent *entry)
 		status = pthread_cond_wait(
 				&entry->current_cond, &entry->current_mutex);
 		if (status) {
-			error(LOGOPT_ANY,
-			      "entry current source condition wait failed");
+			logmsg("entry current source condition wait failed");
 			fatal(status);
 		}
 	}
@@ -595,14 +591,13 @@ void master_source_current_signal(struct master_mapent *entry)
 
 	status = pthread_cond_signal(&entry->current_cond);
 	if (status) {
-		error(LOGOPT_ANY,
-		      "entry current source condition signal failed");
+		logmsg("entry current source condition signal failed");
 		fatal(status);
 	}
 
 	status = pthread_mutex_unlock(&entry->current_mutex);
 	if (status) {
-		error(LOGOPT_ANY, "entry current source unlock failed");
+		logmsg("entry current source unlock failed");
 		fatal(status);
 	}
 
@@ -770,6 +765,7 @@ struct master *master_new(const char *name, unsigned int timeout, unsigned int g
 	master->default_ghost = ghost;
 	master->default_timeout = timeout;
 	master->default_logging = defaults_get_logging();
+	master->logopt = master->default_logging;
 
 	INIT_LIST_HEAD(&master->mounts);
 
@@ -778,11 +774,12 @@ struct master *master_new(const char *name, unsigned int timeout, unsigned int g
 
 int master_read_master(struct master *master, time_t age, int readall)
 {
+	unsigned int logopt = master->logopt;
 	struct mapent_cache *nc;
 
 	nc = cache_init_null_cache(master);
 	if (!nc) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      "failed to init null map cache for %s", master->name);
 		return 0;
 	}
@@ -791,7 +788,7 @@ int master_read_master(struct master *master, time_t age, int readall)
 	master_init_scan();
 
 	if (!lookup_nss_read_master(master, age)) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      "can't read master map %s", master->name);
 		return 0;
 	}
@@ -802,7 +799,7 @@ int master_read_master(struct master *master, time_t age, int readall)
 
 	if (list_empty(&master->mounts)) {
 		master_mutex_unlock();
-		warn(LOGOPT_ANY, "no mounts in table");
+		warn(logopt, "no mounts in table");
 		return 1;
 	}
 
@@ -934,6 +931,7 @@ void master_notify_state_change(struct master *master, int sig)
 	struct autofs_point *ap;
 	struct list_head *p;
 	int state_pipe, cur_state;
+	unsigned int logopt;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cur_state);
 	master_mutex_lock();
@@ -944,6 +942,7 @@ void master_notify_state_change(struct master *master, int sig)
 		entry = list_entry(p, struct master_mapent, list);
 
 		ap = entry->ap;
+		logopt = ap->logopt;
 
 		state_mutex_lock(ap);
 
@@ -978,7 +977,7 @@ void master_notify_state_change(struct master *master, int sig)
 		}
 next:
 		if (next != ST_INVAL)
-			debug(ap->logopt,
+			debug(logopt,
 			      "sig %d switching %s from %d to %d",
 			      sig, ap->path, ap->state, next);
 
@@ -1230,6 +1229,11 @@ int master_list_empty(struct master *master)
 	return res;
 }
 
+inline unsigned int master_get_logopt(void)
+{
+	return master_list ? master_list->logopt : LOGOPT_NONE;
+}
+
 int master_kill(struct master *master)
 {
 	if (!list_empty(&master->mounts))
@@ -1251,6 +1255,6 @@ void dump_master(struct master *master)
 	head = &master->mounts;
 	list_for_each(p, head) {
 		struct master_mapent *this = list_entry(p, struct master_mapent, list);
-		debug(LOGOPT_ANY, "path %s", this->path);
+		logmsg("path %s", this->path);
 	}
 }
diff --git a/lib/master_parse.y b/lib/master_parse.y
index 70b48be..a767f9e 100644
--- a/lib/master_parse.y
+++ b/lib/master_parse.y
@@ -585,13 +585,13 @@ static char *master_strdup(char *str)
 
 static int master_error(const char *s)
 {
-	error(LOGOPT_ANY, "%s while parsing map.", s);
+	logmsg("%s while parsing map.", s);
 	return 0;
 }
 
 static int master_notify(const char *s)
 {
-	warn(LOGOPT_ANY, "syntax error in map near [ %s ]", s);
+	logmsg("syntax error in map near [ %s ]", s);
 	return(0);
 }
 
@@ -704,6 +704,7 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 	struct master_mapent *entry, *new;
 	struct map_source *source;
 	unsigned int logopt = logging;
+	unsigned int m_logopt = master->logopt;
 	int ret;
 
 	local_init_vars();
@@ -758,8 +759,8 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 	} else {
 		if (entry->age && entry->age == age) {
 			if (strcmp(path, "/-")) {
-				warn(LOGOPT_VERBOSE,
-				     "ignoring duplicate indirect mount %s",
+				info(m_logopt,
+				    "ignoring duplicate indirect mount %s",
 				     path);
 				local_free_vars();
 				return 0;
@@ -770,13 +771,12 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 	if (!entry->ap) {
 		ret = master_add_autofs_point(entry, timeout, logopt, ghost, 0);
 		if (!ret) {
-			error(LOGOPT_ANY, "failed to add autofs_point");
+			error(m_logopt, "failed to add autofs_point");
 			if (new)
 				master_free_mapent(new);
 			local_free_vars();
 			return 0;
 		}
-		set_mnt_logging(entry->ap);
 	} else {
 		struct autofs_point *ap = entry->ap;
 		time_t tout = timeout;
@@ -786,14 +786,11 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 		 * use the ghost, log and timeout of the first
 		 */
 		if (entry->age < age) {
-			ap->ghost = ghost;
-			ap->logopt = logopt;
 			ap->exp_timeout = timeout;
 			ap->exp_runfreq = (ap->exp_timeout + CHECK_RATIO - 1) / CHECK_RATIO;
 			if (ap->ioctlfd != -1 && ap->type == LKP_INDIRECT)
 				ioctl(ap->ioctlfd, AUTOFS_IOC_SETTIMEOUT, &tout);
 		}
-		set_mnt_logging(ap);
 	}
 	entry->ap->random_selection = random_selection;
 
@@ -809,7 +806,7 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 	source = master_add_map_source(entry, type, format, age, 
 					local_argc, (const char **) local_argv);
 	if (!source) {
-		error(LOGOPT_ANY, "failed to add source");
+		error(m_logopt, "failed to add source");
 		if (new)
 			master_free_mapent(new);
 		local_free_vars();
@@ -817,9 +814,9 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 	}
 
 	if (!source->mc) {
-		source->mc = cache_init(source);
+		source->mc = cache_init(entry->ap, source);
 		if (!source->mc) {
-			error(LOGOPT_ANY, "failed to init source cache");
+			error(m_logopt, "failed to init source cache");
 			if (new)
 				master_free_mapent(new);
 			local_free_vars();
diff --git a/lib/master_tok.l b/lib/master_tok.l
index 2735223..00cd223 100644
--- a/lib/master_tok.l
+++ b/lib/master_tok.l
@@ -368,7 +368,7 @@ int master_wrap(void)
 
 static void master_echo(void)
 {
-	debug(LOGOPT_NONE, "%s", master_text);
+	logmsg("%s", master_text);
 	return;
 }
 
diff --git a/lib/mounts.c b/lib/mounts.c
index 0e428e8..425a65a 100644
--- a/lib/mounts.c
+++ b/lib/mounts.c
@@ -126,7 +126,7 @@ char *make_options_string(char *path, int pipefd, char *extra)
 
 	options = malloc(MAX_OPTIONS_LEN + 1);
 	if (!options) {
-		crit(LOGOPT_ANY, "can't malloc options string");
+		logerr("can't malloc options string");
 		return NULL;
 	}
 
@@ -141,13 +141,12 @@ char *make_options_string(char *path, int pipefd, char *extra)
 			AUTOFS_MAX_PROTO_VERSION);
 
 	if (len >= MAX_OPTIONS_LEN) {
-		crit(LOGOPT_ANY, "buffer to small for options - truncated");
+		logerr("buffer to small for options - truncated");
 		len = MAX_OPTIONS_LEN - 1;
 	}
 
 	if (len < 0) {
-		crit(LOGOPT_ANY,
-		     "failed to malloc autofs mount options for %s", path);
+		logerr("failed to malloc autofs mount options for %s", path);
 		free(options);
 		return NULL;
 	}
@@ -163,7 +162,7 @@ char *make_mnt_name_string(char *path)
 
 	mnt_name = malloc(MAX_MNT_NAME_LEN + 1);
 	if (!mnt_name) {
-		crit(LOGOPT_ANY, "can't malloc mnt_name string");
+		logerr("can't malloc mnt_name string");
 		return NULL;
 	}
 
@@ -171,13 +170,12 @@ char *make_mnt_name_string(char *path)
 			mnt_name_template, (unsigned) getpid());
 
 	if (len >= MAX_MNT_NAME_LEN) {
-		crit(LOGOPT_ANY, "buffer to small for mnt_name - truncated");
+		logerr("buffer to small for mnt_name - truncated");
 		len = MAX_MNT_NAME_LEN - 1;
 	}
 
 	if (len < 0) {
-		crit(LOGOPT_ANY,
-		     "failed setting up mnt_name for autofs path %s", path);
+		logerr("failed setting up mnt_name for autofs path %s", path);
 		free(mnt_name);
 		return NULL;
 	}
@@ -207,7 +205,7 @@ struct mnt_list *get_mnt_list(const char *table, const char *path, int include)
 	tab = setmntent(table, "r");
 	if (!tab) {
 		char *estr = strerror_r(errno, buf, PATH_MAX - 1);
-		error(LOGOPT_ANY, "setmntent: %s", estr);
+		logerr("setmntent: %s", estr);
 		return NULL;
 	}
 
@@ -398,7 +396,7 @@ int is_mounted(const char *table, const char *path, unsigned int type)
 	tab = setmntent(table, "r");
 	if (!tab) {
 		char *estr = strerror_r(errno, buf, PATH_MAX - 1);
-		error(LOGOPT_ANY, "setmntent: %s", estr);
+		logerr("setmntent: %s", estr);
 		return 0;
 	}
 
@@ -443,7 +441,7 @@ int has_fstab_option(const char *opt)
 	tab = setmntent(_PATH_MNTTAB, "r");
 	if (!tab) {
 		char *estr = strerror_r(errno, buf, PATH_MAX - 1);
-		error(LOGOPT_ANY, "setmntent: %s", estr);
+		logerr("setmntent: %s", estr);
 		return 0;
 	}
 
@@ -471,7 +469,7 @@ char *find_mnt_ino(const char *table, dev_t dev, ino_t ino)
 	tab = setmntent(table, "r");
 	if (!tab) {
 		char *estr = strerror_r(errno, buf, (size_t) PATH_MAX - 1);
-		error(LOGOPT_ANY, "setmntent: %s", estr);
+		logerr("setmntent: %s", estr);
 		return 0;
 	}
 
@@ -667,7 +665,7 @@ struct mnt_list *tree_make_mnt_tree(const char *table, const char *path)
 	tab = setmntent(table, "r");
 	if (!tab) {
 		char *estr = strerror_r(errno, buf, PATH_MAX - 1);
-		error(LOGOPT_ANY, "setmntent: %s", estr);
+		logerr("setmntent: %s", estr);
 		return NULL;
 	}
 
diff --git a/lib/nss_parse.y b/lib/nss_parse.y
index e559696..90b7d25 100644
--- a/lib/nss_parse.y
+++ b/lib/nss_parse.y
@@ -127,13 +127,13 @@ status_exp: STATUS EQUAL ACTION
 
 static int nss_ignore(const char *s)
 {
-	msg("ignored invalid nsswitch config near [ %s ]", s);
+	logmsg("ignored invalid nsswitch config near [ %s ]", s);
 	return(0);
 }
 
 static int nss_error(const char *s)
 {
-	msg("syntax error in nsswitch config near [ %s ]\n", s);
+	logmsg("syntax error in nsswitch config near [ %s ]\n", s);
 	return(0);
 }
 
@@ -167,7 +167,7 @@ int nsswitch_parse(struct list_head *list)
 
 	nsswitch = fopen(NSSWITCH_FILE, "r");
 	if (!nsswitch) {
-		error(LOGOPT_ANY, "couldn't open %s\n", NSSWITCH_FILE);
+		logerr("couldn't open %s\n", NSSWITCH_FILE);
 		return 1;
 	}
 
diff --git a/lib/nss_tok.l b/lib/nss_tok.l
index f96b47f..c435b63 100644
--- a/lib/nss_tok.l
+++ b/lib/nss_tok.l
@@ -135,6 +135,6 @@ int nss_wrap(void)
 
 static void nss_echo(void)
 {
-	msg("%s", nss_text);
+	logmsg("%s", nss_text);
 	return;
 }
diff --git a/lib/parse_subs.c b/lib/parse_subs.c
index 3627f44..5422fef 100644
--- a/lib/parse_subs.c
+++ b/lib/parse_subs.c
@@ -337,9 +337,9 @@ int umount_ent(struct autofs_point *ap, const char *path)
 	 * and EBADSLT relates to CD changer not responding.
 	 */
 	if (!status && (S_ISDIR(st.st_mode) && st.st_dev != ap->dev)) {
-		rv = spawn_umount(log_debug, path, NULL);
+		rv = spawn_umount(ap->logopt, path, NULL);
 	} else if (is_smbfs && (sav_errno == EIO || sav_errno == EBADSLT)) {
-		rv = spawn_umount(log_debug, path, NULL);
+		rv = spawn_umount(ap->logopt, path, NULL);
 	}
 
 	/* We are doing a forced shutcwdown down so unlink busy mounts */
@@ -356,8 +356,8 @@ int umount_ent(struct autofs_point *ap, const char *path)
 		}
 
 		if (ap->state == ST_SHUTDOWN_FORCE) {
-			msg("forcing umount of %s", path);
-			rv = spawn_umount(log_debug, "-l", path, NULL);
+			info(ap->logopt, "forcing umount of %s", path);
+			rv = spawn_umount(ap->logopt, "-l", path, NULL);
 		}
 
 		/*
@@ -503,7 +503,7 @@ int umount_multi_triggers(struct autofs_point *ap, char *root, struct mapent *me
 		 * the offset triggers back.
 		 */
 		if (is_mounted(_PATH_MOUNTED, root, MNTS_REAL)) {
-			msg("unmounting dir = %s", root);
+			info(ap->logopt, "unmounting dir = %s", root);
 			if (umount_ent(ap, root)) {
 				if (!mount_multi_triggers(ap, root, me, "/"))
 					warn(ap->logopt,
diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
index d79a94f..5797639 100644
--- a/lib/rpc_subs.c
+++ b/lib/rpc_subs.c
@@ -96,7 +96,7 @@ static CLIENT *create_udp_client(struct conn_info *info)
 	if (ret || !result) {
 		int err = ghn_errno == -1 ? errno : ghn_errno;
 		char *estr = strerror_r(err, buf, HOST_ENT_BUF_SIZE);
-		error(LOGOPT_ANY, "hostname lookup failed: %s", estr);
+		logerr("hostname lookup failed: %s", estr);
 		goto out_close;
 	}
 	memcpy(&raddr.sin_addr.s_addr, php->h_addr, php->h_length);
@@ -305,7 +305,7 @@ static CLIENT *create_tcp_client(struct conn_info *info)
 	if (ret || !result) {
 		int err = ghn_errno == -1 ? errno : ghn_errno;
 		char *estr =  strerror_r(err, buf, HOST_ENT_BUF_SIZE);
-		error(LOGOPT_ANY, "hostname lookup failed: %s", estr);
+		logerr("hostname lookup failed: %s", estr);
 		goto out_close;
 	}
 	memcpy(&addr.sin_addr.s_addr, php->h_addr, php->h_length);
diff --git a/man/automount.8 b/man/automount.8
index e203a3e..5cd63c7 100644
--- a/man/automount.8
+++ b/man/automount.8
@@ -62,6 +62,22 @@ setting.
 .TP
 .I "\-V, \-\-version"
 Display the version number, then exit.
+.TP
+.I "\-l, \-\-set-log-priority priority path [path,...]"
+Set the daemon log priority to the specified value.  Valid values include
+the numbers 0-7, or the strings emerg, alert, crit, err, warning, notice,
+info, or debug. Log level debug will log everything, log levels info, warn
+(or warning), or notice with enable the daemon verbose logging. Any other
+level will set basic logging. Note that enabling debug or verbose
+logging in the autofs global configuration will override dynamic log level
+changes. For example, if verbose logging is set in the configuration then
+attempting to set logging to basic logging, by using alert, crit, err
+or emerg won't stop the verbose logging. However, setting logging to debug
+will lead to everything (debug logging) being logged witch can then also
+be disabled, returning the daemon to verbose logging.
+.P
+The \fIpath\fP argument corresponds to the automounted
+path name as specified in the master map.
 .SH ARGUMENTS
 \fBautomount\fP takes one optional argument, the name of the master map to
 use.
diff --git a/modules/cyrus-sasl.c b/modules/cyrus-sasl.c
index 68e5dd7..18733f3 100644
--- a/modules/cyrus-sasl.c
+++ b/modules/cyrus-sasl.c
@@ -96,18 +96,18 @@ sasl_log_func(void *context, int level, const char *message)
 	switch (level) {
 	case SASL_LOG_ERR:
 	case SASL_LOG_FAIL:
-		error(LOGOPT_ANY, "%s", message);
+		logerr("%s", message);
 		break;
 	case SASL_LOG_WARN:
-		warn(LOGOPT_ANY, "%s", message);
+		logmsg("%s", message);
 		break;
 	case SASL_LOG_NOTE:
-		info(LOGOPT_ANY, "%s", message);
+		logmsg("%s", message);
 		break;
 	case SASL_LOG_DEBUG:
 	case SASL_LOG_TRACE:
 	case SASL_LOG_PASS:
-		debug(LOGOPT_NONE, "%s", message);
+		debug(LOGOPT_DEBUG, "%s", message);
 		break;
 	default:
 		break;
@@ -129,7 +129,7 @@ getuser_func(void *context, int id, const char **result, unsigned *len)
 			*len = strlen(sasl_auth_id);
 		break;
 	default:
-		error(LOGOPT_ANY, "unknown id in request: %d", id);
+		error(LOGOPT_VERBOSE, "unknown id in request: %d", id);
 		return SASL_FAIL;
 	}
 
@@ -166,7 +166,7 @@ getpass_func(sasl_conn_t *conn, void *context, int id, sasl_secret_t **psecret)
  *                the returned data.
  */
 char **
-get_server_SASL_mechanisms(LDAP *ld)
+get_server_SASL_mechanisms(unsigned logopt, LDAP *ld)
 {
 	int ret;
 	const char *saslattrlist[] = {"supportedSASLmechanisms", NULL};
@@ -178,7 +178,7 @@ get_server_SASL_mechanisms(LDAP *ld)
 				NULL, NULL,
 				NULL, LDAP_NO_LIMIT, &results);
 	if (ret != LDAP_SUCCESS) {
-		error(LOGOPT_ANY, "%s", ldap_err2string(ret));
+		error(logopt, "%s", ldap_err2string(ret));
 		return NULL;
 	}
 
@@ -186,7 +186,7 @@ get_server_SASL_mechanisms(LDAP *ld)
 	if (entry == NULL) {
 		/* No root DSE. (!) */
 		ldap_msgfree(results);
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      "a lookup of \"supportedSASLmechanisms\" returned "
 		      "no results.");
 		return NULL;
@@ -196,7 +196,7 @@ get_server_SASL_mechanisms(LDAP *ld)
 	ldap_msgfree(results);
 	if (mechanisms == NULL) {
 		/* Well, that was a waste of time. */
-		msg("No SASL authentication mechanisms are supported"
+		info(logopt, "No SASL authentication mechanisms are supported"
 		    " by the LDAP server.");
 		return NULL;
 	}
@@ -208,7 +208,7 @@ get_server_SASL_mechanisms(LDAP *ld)
  *  Returns 0 upon successful connect, -1 on failure.
  */
 int
-do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
+do_sasl_bind(unsigned logopt, LDAP *ld, sasl_conn_t *conn, const char **clientout,
 	     unsigned int *clientoutlen, const char *auth_mech, int sasl_result)
 {
 	int ret, msgid, bind_result;
@@ -226,7 +226,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 				     &client_cred : NULL,
 				     NULL, NULL, &msgid);
 		if (ret != LDAP_SUCCESS) {
-			crit(LOGOPT_ANY,
+			crit(logopt,
 			     "Error sending sasl_bind request to "
 			     "the server: %s", ldap_err2string(ret));
 			return -1;
@@ -236,7 +236,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 		results = NULL;
 		ret = ldap_result(ld, msgid, LDAP_MSG_ALL, NULL, &results);
 		if (ret != LDAP_RES_BIND) {
-			crit(LOGOPT_ANY,
+			crit(logopt,
 			     "Error while waiting for response to "
 			     "sasl_bind request: %s", ldap_err2string(ret));
 			return -1;
@@ -264,7 +264,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 			ret = ldap_get_option(ld, LDAP_OPT_RESULT_CODE,
 					      &bind_result);
 			if (ret != LDAP_SUCCESS) {
-				crit(LOGOPT_ANY,
+				crit(logopt,
 				     "Error retrieving response to sasl_bind "
 				     "request: %s", ldap_err2string(ret));
 				ret = -1;
@@ -277,7 +277,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 				bind_result = ret;
 				break;
 			default:
-				warn(LOGOPT_ANY,
+				warn(logopt,
 				     "Error parsing response to sasl_bind "
 				     "request: %s.", ldap_err2string(ret));
 				break;
@@ -299,7 +299,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 		expected_data = sasl_result == SASL_CONTINUE;
 
 		if (have_data && !expected_data) {
-			warn(LOGOPT_ANY,
+			warn(logopt,
 			     "The LDAP server sent data in response to our "
 			     "bind request, but indicated that the bind was "
 			     "complete. LDAP SASL bind with mechansim %s "
@@ -308,7 +308,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 			break;
 		}
 		if (expected_data && !have_data) {
-			warn(LOGOPT_ANY,
+			warn(logopt,
 			     "The LDAP server indicated that the LDAP SASL "
 			     "bind was incomplete, but did not provide the "
 			     "required data to proceed. LDAP SASL bind with "
@@ -340,7 +340,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
 			 */
 			if ((*clientoutlen > 0) &&
 			    (bind_result != LDAP_SASL_BIND_IN_PROGRESS)) {
-				warn(LOGOPT_ANY,
+				warn(logopt,
 				     "We have data for the server, "
 				     "but it thinks we are done!");
 				/* XXX should print out debug data here */
@@ -372,7 +372,7 @@ do_sasl_bind(LDAP *ld, sasl_conn_t *conn, const char **clientout,
  *  Upon failure, -1 is returned.
  */
 int
-sasl_do_kinit(struct lookup_context *ctxt)
+sasl_do_kinit(unsigned logopt, struct lookup_context *ctxt)
 {
 	krb5_error_code ret;
 	krb5_principal tgs_princ, krb5_client_princ = ctxt->krb5_client_princ;
@@ -384,33 +384,33 @@ sasl_do_kinit(struct lookup_context *ctxt)
 		return 0;
 	ctxt->kinit_done = 1;
 
-	debug(LOGOPT_NONE,
+	debug(logopt,
 	      "initializing kerberos ticket: client principal %s ",
 	      ctxt->client_princ ? "" : "autofsclient");
 
 	ret = krb5_init_context(&ctxt->krb5ctxt);
 	if (ret) {
-		error(LOGOPT_ANY, "krb5_init_context failed with %d", ret);
+		error(logopt, "krb5_init_context failed with %d", ret);
 		return -1;
 	}
 
 	ret = krb5_cc_resolve(ctxt->krb5ctxt, krb5ccval, &ctxt->krb5_ccache);
 	if (ret) {
-		error(LOGOPT_ANY, "krb5_cc_resolve failed with error %d",
+		error(logopt, "krb5_cc_resolve failed with error %d",
 		      ret);
 		krb5_free_context(ctxt->krb5ctxt);
 		return -1;
 	}
 
 	if (ctxt->client_princ) {
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      "calling krb5_parse_name on client principal %s",
 		      ctxt->client_princ);
 
 		ret = krb5_parse_name(ctxt->krb5ctxt, ctxt->client_princ,
 				      &krb5_client_princ);
 		if (ret) {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      "krb5_parse_name failed for "
 			      "specified client principal %s",
 			      ctxt->client_princ);
@@ -419,14 +419,14 @@ sasl_do_kinit(struct lookup_context *ctxt)
 	} else {
 		char *tmp_name = NULL;
 
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      "calling krb5_sname_to_principal using defaults");
 
 		ret = krb5_sname_to_principal(ctxt->krb5ctxt, NULL,
 					"autofsclient", KRB5_NT_SRV_HST, 
 					&krb5_client_princ);
 		if (ret) {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      "krb5_sname_to_principal failed for "
 			      "%s with error %d",
 			      ctxt->client_princ ? "" : "autofsclient", ret);
@@ -437,13 +437,13 @@ sasl_do_kinit(struct lookup_context *ctxt)
 		ret = krb5_unparse_name(ctxt->krb5ctxt,
 					krb5_client_princ, &tmp_name);
 		if (ret) {
-			debug(LOGOPT_NONE,
+			debug(logopt,
 			      "krb5_unparse_name failed with error %d",
 			      ret);
 			goto out_cleanup_cc;
 		}
 
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      "principal used for authentication: \"%s\"", tmp_name);
 
 		krb5_free_unparsed_name(ctxt->krb5ctxt, tmp_name);
@@ -458,19 +458,19 @@ sasl_do_kinit(struct lookup_context *ctxt)
 		krb5_princ_realm(ctxt->krb5ctxt, krb5_client_princ)->data,
 		0);
 	if (ret) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      "krb5_build_principal failed with error %d", ret);
 		goto out_cleanup_cc;
 	}
 
 	ret = krb5_unparse_name(ctxt->krb5ctxt, tgs_princ, &tgs_name);
 	if (ret) {
-		error(LOGOPT_ANY, "krb5_unparse_name failed with error %d",
+		error(logopt, "krb5_unparse_name failed with error %d",
 		      ret);
 		goto out_cleanup_cc;
 	}
 
-	debug(LOGOPT_NONE, "Using tgs name %s", tgs_name);
+	debug(logopt, "Using tgs name %s", tgs_name);
 
 	memset(&my_creds, 0, sizeof(my_creds));
 	ret = krb5_get_init_creds_keytab(ctxt->krb5ctxt, &my_creds,
@@ -479,7 +479,7 @@ sasl_do_kinit(struct lookup_context *ctxt)
 					 0 /* relative start time */,
 					 tgs_name, NULL);
 	if (ret) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      "krb5_get_init_creds_keytab failed with error %d",
 		      ret);
 		goto out_cleanup_unparse;
@@ -500,7 +500,7 @@ sasl_do_kinit(struct lookup_context *ctxt)
 		fatal(status);
 
 	if (ret) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      "krb5_cc_initialize failed with error %d", ret);
 		goto out_cleanup_unparse;
 	}
@@ -508,7 +508,7 @@ sasl_do_kinit(struct lookup_context *ctxt)
 	/* and store credentials for that principal */
 	ret = krb5_cc_store_cred(ctxt->krb5ctxt, ctxt->krb5_ccache, &my_creds);
 	if (ret) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      "krb5_cc_store_cred failed with error %d", ret);
 		goto out_cleanup_unparse;
 	}
@@ -516,12 +516,12 @@ sasl_do_kinit(struct lookup_context *ctxt)
 	/* finally, set the environment variable to point to our
 	 * credentials cache */
 	if (setenv(krb5ccenv, krb5ccval, 1) != 0) {
-		error(LOGOPT_ANY, "setenv failed with %d", errno);
+		error(logopt, "setenv failed with %d", errno);
 		goto out_cleanup_unparse;
 	}
 	ctxt->kinit_successful = 1;
 
-	debug(LOGOPT_NONE, "Kerberos authentication was successful!");
+	debug(logopt, "Kerberos authentication was successful!");
 
 	krb5_free_unparsed_name(ctxt->krb5ctxt, tgs_name);
 
@@ -540,7 +540,7 @@ out_cleanup_cc:
 	else
 		ret = krb5_cc_destroy(ctxt->krb5ctxt, ctxt->krb5_ccache);
 	if (ret)
-		warn(LOGOPT_ANY,
+		warn(logopt,
 		     "krb5_cc_destroy failed with non-fatal error %d", ret);
 
 	status = pthread_mutex_unlock(&krb5cc_mutex);
@@ -559,7 +559,7 @@ out_cleanup_cc:
  *  Returns a valid sasl_conn_t pointer upon success, NULL on failure.
  */
 sasl_conn_t *
-sasl_bind_mech(LDAP *ldap, struct lookup_context *ctxt, const char *mech)
+sasl_bind_mech(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt, const char *mech)
 {
 	sasl_conn_t *conn;
 	char *tmp, *host = NULL;
@@ -569,15 +569,15 @@ sasl_bind_mech(LDAP *ldap, struct lookup_context *ctxt, const char *mech)
 	int result;
 
 	if (!strncmp(mech, "GSSAPI", 6)) {
-		if (sasl_do_kinit(ctxt) != 0)
+		if (sasl_do_kinit(logopt, ctxt) != 0)
 			return NULL;
 	}
 
-	debug(LOGOPT_NONE, "Attempting sasl bind with mechanism %s", mech);
+	debug(logopt, "Attempting sasl bind with mechanism %s", mech);
 
 	result = ldap_get_option(ldap, LDAP_OPT_HOST_NAME, &host);
 	if (result != LDAP_SUCCESS || !host) {
-		debug(LOGOPT_NONE, "failed to get hostname for connection");
+		debug(logopt, "failed to get hostname for connection");
 		return NULL;
 	}
 
@@ -587,7 +587,7 @@ sasl_bind_mech(LDAP *ldap, struct lookup_context *ctxt, const char *mech)
 	/* Create a new authentication context for the service. */
 	result = sasl_client_new("ldap", host, NULL, NULL, NULL, 0, &conn);
 	if (result != SASL_OK) {
-		error(LOGOPT_ANY, "sasl_client_new failed with error %d",
+		error(logopt, "sasl_client_new failed with error %d",
 		      result);
 		ldap_memfree(host);
 		return NULL;
@@ -599,23 +599,23 @@ sasl_bind_mech(LDAP *ldap, struct lookup_context *ctxt, const char *mech)
 
 	/* OK and CONTINUE are the only non-fatal return codes here. */
 	if ((result != SASL_OK) && (result != SASL_CONTINUE)) {
-		error(LOGOPT_ANY, "sasl_client start failed with error: %s",
+		error(logopt, "sasl_client start failed with error: %s",
 		      sasl_errdetail(conn));
 		ldap_memfree(host);
 		sasl_dispose(&conn);
 		return NULL;
 	}
 
-	result = do_sasl_bind(ldap, conn,
+	result = do_sasl_bind(logopt, ldap, conn,
 			 &clientout, &clientoutlen, chosen_mech, result);
 	if (result == 0) {
 		ldap_memfree(host);
-		debug(LOGOPT_NONE, "sasl bind with mechanism %s succeeded",
+		debug(logopt, "sasl bind with mechanism %s succeeded",
 		      chosen_mech);
 		return conn;
 	}
 
-	info(LOGOPT_ANY, "sasl bind with mechanism %s failed", mech);
+	info(logopt, "sasl bind with mechanism %s failed", mech);
 
 	/* sasl bind failed */
 	ldap_memfree(host);
@@ -629,14 +629,14 @@ sasl_bind_mech(LDAP *ldap, struct lookup_context *ctxt, const char *mech)
  *  -1 on error or if no mechanism is supported by both client and server.
  */
 sasl_conn_t *
-sasl_choose_mech(LDAP *ldap, struct lookup_context *ctxt)
+sasl_choose_mech(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	sasl_conn_t *conn;
 	int authenticated;
 	int i;
 	char **mechanisms;
 
-	mechanisms = get_server_SASL_mechanisms(ldap);
+	mechanisms = get_server_SASL_mechanisms(logopt, ldap);
 	if (!mechanisms)
 		return NULL;
 
@@ -652,12 +652,11 @@ sasl_choose_mech(LDAP *ldap, struct lookup_context *ctxt)
 		if (authtype_requires_creds(mechanisms[i]))
 			continue;
 
-		conn = sasl_bind_mech(ldap, ctxt, mechanisms[i]);
+		conn = sasl_bind_mech(logopt, ldap, ctxt, mechanisms[i]);
 		if (conn) {
 			ctxt->sasl_mech = strdup(mechanisms[i]);
 			if (!ctxt->sasl_mech) {
-				crit(LOGOPT_ANY,
-				     "Successfully authenticated with "
+				crit(logopt, "Successfully authenticated with "
 				     "mechanism %s, but failed to allocate "
 				     "memory to hold the mechanism type.",
 				     mechanisms[i]);
@@ -668,11 +667,11 @@ sasl_choose_mech(LDAP *ldap, struct lookup_context *ctxt)
 			authenticated = 1;
 			break;
 		}
-		debug(LOGOPT_NONE, "Failed to authenticate with mech %s",
+		debug(logopt, "Failed to authenticate with mech %s",
 		      mechanisms[i]);
 	}
 
-	debug(LOGOPT_NONE, "authenticated: %d, sasl_mech: %s",
+	debug(logopt, "authenticated: %d, sasl_mech: %s",
 	      authenticated, ctxt->sasl_mech);
 
 	ldap_value_free(mechanisms);
@@ -680,14 +679,14 @@ sasl_choose_mech(LDAP *ldap, struct lookup_context *ctxt)
 }
 
 int
-autofs_sasl_bind(LDAP *ldap, struct lookup_context *ctxt)
+autofs_sasl_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	sasl_conn_t *conn;
 
 	if (!ctxt->sasl_mech)
 		return -1;
 
-	conn = sasl_bind_mech(ldap, ctxt, ctxt->sasl_mech);
+	conn = sasl_bind_mech(logopt, ldap, ctxt, ctxt->sasl_mech);
 	if (!conn)
 		return -1;
 
@@ -717,13 +716,13 @@ autofs_sasl_unbind(struct lookup_context *ctxt)
  * -1  -  Failure
  */
 int
-autofs_sasl_init(LDAP *ldap, struct lookup_context *ctxt)
+autofs_sasl_init(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	sasl_conn_t *conn;
 
 	/* Start up Cyrus SASL--only needs to be done once. */
 	if (sasl_client_init(callbacks) != SASL_OK) {
-		error(LOGOPT_ANY, "sasl_client_init failed");
+		error(logopt, "sasl_client_init failed");
 		return -1;
 	}
 
@@ -736,9 +735,9 @@ autofs_sasl_init(LDAP *ldap, struct lookup_context *ctxt)
 	 *  select one.
 	 */
 	if (ctxt->sasl_mech)
-		conn = sasl_bind_mech(ldap, ctxt, ctxt->sasl_mech);
+		conn = sasl_bind_mech(logopt, ldap, ctxt, ctxt->sasl_mech);
 	else
-		conn = sasl_choose_mech(ldap, ctxt);
+		conn = sasl_choose_mech(logopt, ldap, ctxt);
 
 	if (conn) {
 		sasl_dispose(&conn);
@@ -772,8 +771,7 @@ autofs_sasl_done(struct lookup_context *ctxt)
 		else 
 			ret = krb5_cc_destroy(ctxt->krb5ctxt, ctxt->krb5_ccache);
 		if (ret)
-			warn(LOGOPT_ANY,
-			     "krb5_cc_destroy failed with non-fatal error %d",
+			logmsg("krb5_cc_destroy failed with non-fatal error %d",
 			     ret);
 
 		status = pthread_mutex_unlock(&krb5cc_mutex);
@@ -782,8 +780,7 @@ autofs_sasl_done(struct lookup_context *ctxt)
 
 		krb5_free_context(ctxt->krb5ctxt);
 		if (unsetenv(krb5ccenv) != 0)
-			warn(LOGOPT_ANY,
-			     "unsetenv failed with error %d", errno);
+			logerr("unsetenv failed with error %d", errno);
 
 		ctxt->krb5ctxt = NULL;
 		ctxt->krb5_ccache = NULL;
diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 31ee0fb..921b32b 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -63,13 +63,13 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return 1;
 	}
 
 	if (argc < 1) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "No map name");
+		logerr(MODPREFIX "No map name");
 		return 1;
 	}
 
@@ -77,21 +77,21 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 
 	if (ctxt->mapname[0] != '/') {
 		free(ctxt);
-		msg(MODPREFIX "file map %s is not an absolute pathname",
-		    argv[0]);
+		logmsg(MODPREFIX
+		     "file map %s is not an absolute pathname", argv[0]);
 		return 1;
 	}
 
 	if (access(ctxt->mapname, R_OK)) {
 		free(ctxt);
-		msg(MODPREFIX "file map %s missing or not readable",
-		    argv[0]);
+		warn(LOGOPT_NONE, MODPREFIX
+		    "file map %s missing or not readable", argv[0]);
 		return 1;
 	}
 
 	if (stat(ctxt->mapname, &st)) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "file map %s, could not stat",
+		logmsg(MODPREFIX "file map %s, could not stat",
 		     argv[0]);
 		return 1;
 	}
@@ -104,7 +104,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
 	if (!ctxt->parse) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logmsg(MODPREFIX "failed to open parse context");
 		return 1;
 	}
 	*context = ctxt;
@@ -112,7 +112,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	return 0;
 }
 
-static int read_one(FILE *f, char *key, unsigned int *k_len, char *mapent, unsigned int *m_len)
+static int read_one(unsigned logopt, FILE *f, char *key, unsigned int *k_len, char *mapent, unsigned int *m_len)
 {
 	char *kptr, *p;
 	int mapent_len, key_len;
@@ -193,7 +193,7 @@ static int read_one(FILE *f, char *key, unsigned int *k_len, char *mapent, unsig
 				if (gotten == got_plus)
 					goto got_it;
 				else if (escape == esc_all) {
-					warn(LOGOPT_ANY, MODPREFIX
+					warn(logopt, MODPREFIX
 					    "unmatched \" in map key %s", key);
 					goto next;
 				} else if (escape != esc_val)
@@ -208,7 +208,7 @@ static int read_one(FILE *f, char *key, unsigned int *k_len, char *mapent, unsig
 				if (key_len == KEY_MAX_LEN) {
 					state = st_badent;
 					gotten = got_nothing;
-					warn(LOGOPT_ANY,
+					warn(logopt,
 					      MODPREFIX "map key \"%s...\" "
 					      "is too long.  The maximum key "
 					      "length is %d", key,
@@ -245,7 +245,7 @@ static int read_one(FILE *f, char *key, unsigned int *k_len, char *mapent, unsig
 				state = st_begin;
 				if (gotten == got_real || gotten == getting)
 					goto got_it;
-				warn(LOGOPT_ANY, MODPREFIX 
+				warn(logopt, MODPREFIX 
 				      "bad map entry \"%s...\" for key "
 				      "\"%s\"", mapent, key);
 				goto next;
@@ -286,7 +286,7 @@ static int read_one(FILE *f, char *key, unsigned int *k_len, char *mapent, unsig
 			if (ch == '\n') {
 				if (escape == esc_all) {
 					state = st_begin;
-					warn(LOGOPT_ANY, MODPREFIX
+					warn(logopt, MODPREFIX
 					     "unmatched \" in %s for key %s",
 					     mapent, key);
 					goto next;
@@ -310,7 +310,7 @@ static int read_one(FILE *f, char *key, unsigned int *k_len, char *mapent, unsig
 				   	goto got_it;
 				ungetc(nch, f);
 			} else {
-				warn(LOGOPT_ANY,
+				warn(logopt,
 				      MODPREFIX "map entry \"%s...\" for key "
 				      "\"%s\" is too long.  The maximum entry"
 				      " size is %d", mapent, key,
@@ -388,6 +388,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	unsigned int timeout = master->default_timeout;
 	unsigned int logging = master->default_logging;
+	unsigned int logopt = master->logopt;
 	char *buffer;
 	int blen;
 	char *path;
@@ -402,29 +403,28 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		return NSS_STATUS_UNAVAIL;
 
 	if (master->depth > MAX_INCLUDE_DEPTH) {
-		error(LOGOPT_ANY,
-		      MODPREFIX
+		error(logopt, MODPREFIX
 		      "maximum include depth exceeded %s", master->name);
 		return NSS_STATUS_UNAVAIL;
 	}
 
 	path = alloca(KEY_MAX_LEN + 1);
 	if (!path) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX "could not malloc storage for path");
 		return NSS_STATUS_UNAVAIL;
 	}
 
 	ent = alloca(MAPENT_MAX_LEN + 1);
 	if (!ent) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX "could not malloc storage for mapent");
 		return NSS_STATUS_UNAVAIL;
 	}
 
 	f = fopen(ctxt->mapname, "r");
 	if (!f) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX "could not open master map file %s",
 		      ctxt->mapname);
 		return NSS_STATUS_UNAVAIL;
@@ -438,19 +438,19 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	}
 
 	while(1) {
-		entry = read_one(f, path, &path_len, ent, &ent_len);
+		entry = read_one(logopt, f, path, &path_len, ent, &ent_len);
 		if (!entry) {
 			if (feof(f))
 				break;
 			if (ferror(f)) {
-				warn(LOGOPT_ANY, MODPREFIX
+				warn(logopt, MODPREFIX
 				     "error reading map %s", ctxt->mapname);
 				break;
 			}
 			continue;
 		}
 
-		debug(LOGOPT_NONE, MODPREFIX "read entry %s", path);
+		debug(logopt, MODPREFIX "read entry %s", path);
 
 		/*
 		 * If key starts with '+' it has to be an
@@ -470,7 +470,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 			master->depth++;
 			status = lookup_nss_read_master(master, age);
 			if (!status)
-				warn(LOGOPT_ANY,
+				warn(logopt,
 				     MODPREFIX
 				     "failed to read included master map %s",
 				     master->name);
@@ -482,7 +482,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 			blen = path_len + 1 + ent_len + 1;
 			buffer = malloc(blen);
 			if (!buffer) {
-				error(LOGOPT_ANY,
+				error(logopt,
 				      MODPREFIX "could not malloc parse buffer");
 				return NSS_STATUS_UNAVAIL;
 			}
@@ -503,7 +503,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	}
 
 	if (fstat(fd, &st)) {
-		crit(LOGOPT_ANY, MODPREFIX "file map %s, could not stat",
+		crit(logopt, MODPREFIX "file map %s, could not stat",
 		       ctxt->mapname);
 		return NSS_STATUS_UNAVAIL;
 	}
@@ -684,12 +684,12 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	}
 
 	while(1) {
-		entry = read_one(f, key, &k_len, mapent, &m_len);
+		entry = read_one(ap->logopt, f, key, &k_len, mapent, &m_len);
 		if (!entry) {
 			if (feof(f))
 				break;
 			if (ferror(f)) {
-				warn(LOGOPT_ANY, MODPREFIX
+				warn(ap->logopt, MODPREFIX
 				      "error reading map %s", ctxt->mapname);
 				break;
 			}
@@ -791,7 +791,7 @@ static int lookup_one(struct autofs_point *ap,
 	}
 
 	while(1) {
-		entry = read_one(f, mkey, &k_len, mapent, &m_len);
+		entry = read_one(ap->logopt, f, mkey, &k_len, mapent, &m_len);
 		if (entry) {
 			/*
 			 * If key starts with '+' it has to be an
@@ -860,7 +860,7 @@ static int lookup_one(struct autofs_point *ap,
 			break;
 
 		if (ferror(f)) {
-			warn(LOGOPT_ANY, MODPREFIX
+			warn(ap->logopt, MODPREFIX
 			      "error reading map %s", ctxt->mapname);
 			break;
 		}		
@@ -904,7 +904,7 @@ static int lookup_wild(struct autofs_point *ap, struct lookup_context *ctxt)
 	}
 
 	while(1) {
-		entry = read_one(f, mkey, &k_len, mapent, &m_len);
+		entry = read_one(ap->logopt, f, mkey, &k_len, mapent, &m_len);
 		if (entry) {
 			int eq;
 
@@ -925,7 +925,7 @@ static int lookup_wild(struct autofs_point *ap, struct lookup_context *ctxt)
 			break;
 
 		if (ferror(f)) {
-			warn(LOGOPT_ANY, MODPREFIX
+			warn(ap->logopt, MODPREFIX
 			      "error reading map %s", ctxt->mapname);
 			break;
 		}		
diff --git a/modules/lookup_hesiod.c b/modules/lookup_hesiod.c
index f30e9b2..649e24c 100644
--- a/modules/lookup_hesiod.c
+++ b/modules/lookup_hesiod.c
@@ -48,7 +48,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return 1;
 	}
 
@@ -58,7 +58,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	/* Initialize the hesiod context. */
 	if (hesiod_init(&(ctxt->hesiod_context)) != 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "hesiod_init(): %s", estr);
+		logerr(MODPREFIX "hesiod_init(): %s", estr);
 		free(ctxt);
 		return 1;
 	}
@@ -70,7 +70,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	/* Open the parser, if we can. */
 	ctxt->parser = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
 	if (!ctxt->parser) {
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logerr(MODPREFIX "failed to open parse context");
 		free(ctxt);
 		return 1;
 	}
diff --git a/modules/lookup_hosts.c b/modules/lookup_hosts.c
index d711611..d746e42 100644
--- a/modules/lookup_hosts.c
+++ b/modules/lookup_hosts.c
@@ -57,7 +57,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return 1;
 	}
 
@@ -65,7 +65,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc, argv);
 	if (!ctxt->parse) {
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logerr(MODPREFIX "failed to open parse context");
 		free(ctxt);
 		return 1;
 	}
@@ -94,7 +94,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 
 	status = pthread_mutex_lock(&hostent_mutex);
 	if (status) {
-		error(LOGOPT_ANY, MODPREFIX "failed to lock hostent mutex");
+		error(ap->logopt, MODPREFIX "failed to lock hostent mutex");
 		return NSS_STATUS_UNAVAIL;
 	}
 
@@ -110,7 +110,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 
 	status = pthread_mutex_unlock(&hostent_mutex);
 	if (status)
-		error(LOGOPT_ANY, MODPREFIX "failed to unlock hostent mutex");
+		error(ap->logopt, MODPREFIX "failed to unlock hostent mutex");
 
 	source->age = age;
 
@@ -157,10 +157,10 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		}
 
 		if (*name == '/')
-			msg(MODPREFIX
+			info(ap->logopt, MODPREFIX
 			      "can't find path in hosts map %s", name);
 		else
-			msg(MODPREFIX
+			info(ap->logopt, MODPREFIX
 			      "can't find path in hosts map %s/%s",
 			      ap->path, name);
 
@@ -216,7 +216,7 @@ done:
 			if (!mapent) {
 				char *estr;
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(ap->logopt, MODPREFIX "malloc: %s", estr);
+				logerr(MODPREFIX "malloc: %s", estr);
 				rpc_exports_free(exp);
 				return NSS_STATUS_UNAVAIL;
 			}
@@ -230,7 +230,7 @@ done:
 			if (!mapent) {
 				char *estr;
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(ap->logopt, MODPREFIX "malloc: %s", estr);
+				logerr(MODPREFIX "malloc: %s", estr);
 				rpc_exports_free(exp);
 				return NSS_STATUS_UNAVAIL;
 			}
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index c0f228b..00215af 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -49,9 +49,9 @@ static struct ldap_schema common_schema[] = {
 };
 static unsigned int common_schema_count = sizeof(common_schema)/sizeof(struct ldap_schema);
 
-static LDAP *auth_init(const char *, struct lookup_context *);
+static LDAP *auth_init(unsigned logopt, const char *, struct lookup_context *);
 
-int bind_ldap_anonymous(LDAP *ldap, struct lookup_context *ctxt)
+int bind_ldap_anonymous(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	int rv;
 
@@ -62,15 +62,14 @@ int bind_ldap_anonymous(LDAP *ldap, struct lookup_context *ctxt)
 
 	if (rv != LDAP_SUCCESS) {
 		if (!ctxt->uri) {
-			crit(LOGOPT_ANY,
-			     MODPREFIX "Unable to bind to the LDAP server: "
+			crit(logopt, MODPREFIX
+			     "Unable to bind to the LDAP server: "
 			     "%s, error %s", ctxt->server ? "" : "(default)",
 			     ldap_err2string(rv));
 		} else {
 			struct ldap_uri *uri;
 			uri = list_entry(ctxt->uri->next, struct ldap_uri, list);
-			warn(LOGOPT_ANY,
-			     MODPREFIX "Unable to bind to the LDAP server: "
+			info(logopt, MODPREFIX "Unable to bind to the LDAP server: "
 			     "%s, error %s", uri->uri, ldap_err2string(rv));
 		}
 		return -1;
@@ -79,12 +78,11 @@ int bind_ldap_anonymous(LDAP *ldap, struct lookup_context *ctxt)
 	return 0;
 }
 
-int unbind_ldap_connection(LDAP *ldap, struct lookup_context *ctxt)
+int unbind_ldap_connection(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	int rv;
 
 #ifdef WITH_SASL
-	debug(LOGOPT_NONE, "use_tls: %d", ctxt->use_tls);
 	/*
 	 * The OpenSSL library can't handle having its message and error
 	 * string database loaded multiple times and segfaults if the
@@ -102,13 +100,12 @@ int unbind_ldap_connection(LDAP *ldap, struct lookup_context *ctxt)
 
 	rv = ldap_unbind_ext(ldap, NULL, NULL);
 	if (rv != LDAP_SUCCESS)
-		error(LOGOPT_ANY,
-		     "unbind failed: %s", ldap_err2string(rv));
+		error(logopt, "unbind failed: %s", ldap_err2string(rv));
 
 	return rv;
 }
 
-LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
+LDAP *init_ldap_connection(unsigned logopt, const char *uri, struct lookup_context *ctxt)
 {
 	LDAP *ldap = NULL;
 	struct timeval timeout     = { ctxt->timeout, 0 };
@@ -120,9 +117,9 @@ LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
 	/* Initialize the LDAP context. */
 	rv = ldap_initialize(&ldap, uri);
 	if (rv != LDAP_OPT_SUCCESS) {
-		crit(LOGOPT_ANY,
-		     MODPREFIX "couldn't initialize LDAP connection to %s",
-		     uri ? uri : "default server");
+		info(logopt, MODPREFIX
+		     "couldn't initialize LDAP connection to %s",
+		     uri ? uri : "default");
 		return NULL;
 	}
 
@@ -133,7 +130,7 @@ LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
 		ldap_unbind_ext(ldap, NULL, NULL);
 		rv = ldap_initialize(&ldap, uri);
 		if (rv != LDAP_OPT_SUCCESS) {
-			crit(LOGOPT_ANY, MODPREFIX "couldn't initialize LDAP");
+			crit(logopt, MODPREFIX "couldn't initialize LDAP");
 			return NULL;
 		}
 		ctxt->version = 2;
@@ -144,7 +141,7 @@ LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
 		/* Set synchronous call timeout */
 		rv = ldap_set_option(ldap, LDAP_OPT_TIMEOUT, &timeout);
 		if (rv != LDAP_OPT_SUCCESS)
-			info(LOGOPT_ANY, MODPREFIX
+			info(logopt, MODPREFIX
 			     "failed to set synchronous call timeout to %d",
 			     timeout.tv_sec);
 	}
@@ -152,16 +149,14 @@ LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
 	/* Sane network timeout */
 	rv = ldap_set_option(ldap, LDAP_OPT_NETWORK_TIMEOUT, &net_timeout);
 	if (rv != LDAP_OPT_SUCCESS)
-		info(LOGOPT_ANY,
-		     MODPREFIX "failed to set connection timeout to %d",
+		info(logopt, MODPREFIX "failed to set connection timeout to %d",
 		     net_timeout.tv_sec);
 
 #ifdef WITH_SASL
 	if (ctxt->use_tls) {
 		if (ctxt->version == 2) {
 			if (ctxt->tls_required) {
-				error(LOGOPT_ANY,
-				    MODPREFIX
+				error(logopt, MODPREFIX
 				    "TLS required but connection is version 2");
 				ldap_unbind_ext(ldap, NULL, NULL);
 				return NULL;
@@ -171,16 +166,15 @@ LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
 
 		rv = ldap_start_tls_s(ldap, NULL, NULL);
 		if (rv != LDAP_SUCCESS) {
-			unbind_ldap_connection(ldap, ctxt);
+			unbind_ldap_connection(logopt, ldap, ctxt);
 			if (ctxt->tls_required) {
-				error(LOGOPT_ANY,
-				      MODPREFIX
+				error(logopt, MODPREFIX
 				      "TLS required but START_TLS failed: %s",
 				      ldap_err2string(rv));
 				return NULL;
 			}
 			ctxt->use_tls = LDAP_TLS_DONT_USE;
-			ldap = init_ldap_connection(uri, ctxt);
+			ldap = init_ldap_connection(logopt, uri, ctxt);
 			if (ldap)
 				ctxt->use_tls = LDAP_TLS_INIT;
 			return ldap;
@@ -192,7 +186,7 @@ LDAP *init_ldap_connection(const char *uri, struct lookup_context *ctxt)
 	return ldap;
 }
 
-static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *class, const char *key)
+static int get_query_dn(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt, const char *class, const char *key)
 {
 	char buf[PARSE_MAX_BUF];
 	char *query, *dn, *qdn;
@@ -206,7 +200,7 @@ static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *cla
 	attrs[1] = NULL;
 
 	if (!ctxt->mapname && !ctxt->base) {
-		error(LOGOPT_ANY, MODPREFIX "no master map to lookup");
+		error(logopt, MODPREFIX "no master map to lookup");
 		return 0;
 	}
 
@@ -218,7 +212,7 @@ static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *cla
 	query = alloca(l);
 	if (query == NULL) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		crit(logopt, MODPREFIX "alloca: %s", estr);
 		return NSS_STATUS_UNAVAIL;
 	}
 
@@ -229,14 +223,14 @@ static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *cla
 	if (ctxt->mapname) {
 		if (sprintf(query, "(&(objectclass=%s)(%s=%.*s))", class,
 		     key, (int) strlen(ctxt->mapname), ctxt->mapname) >= l) {
-			debug(LOGOPT_NONE,
+			debug(logopt,
 			      MODPREFIX "error forming query string");
 			return 0;
 		}
 		scope = LDAP_SCOPE_SUBTREE;
 	} else {
 		if (sprintf(query, "(objectclass=%s)", class) >= l) {
-			debug(LOGOPT_NONE,
+			debug(logopt,
 			      MODPREFIX "error forming query string");
 			return 0;
 		}
@@ -259,15 +253,14 @@ static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *cla
 	else {
 		struct ldap_searchdn *this = ctxt->sdns;
 
-		debug(LOGOPT_NONE, MODPREFIX
-			      "check search base list");
+		debug(logopt, MODPREFIX "check search base list");
 
 		while (this) {
 			rv = ldap_search_s(ldap, this->basedn,
 					   scope, query, attrs, 0, &result);
 
 			if ((rv == LDAP_SUCCESS) && result) {
-				debug(LOGOPT_NONE, MODPREFIX
+				debug(logopt, MODPREFIX
 				      "found search base under %s",
 				      this->basedn);
 				break;
@@ -283,7 +276,7 @@ static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *cla
 	}
 
 	if ((rv != LDAP_SUCCESS) || !result) {
-		error(LOGOPT_NONE,
+		error(logopt,
 		      MODPREFIX "query failed for %s: %s",
 		      query, ldap_err2string(rv));
 		return 0;
@@ -292,9 +285,9 @@ static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt, const char *cla
 	e = ldap_first_entry(ldap, result);
 	if (e) {
 		dn = ldap_get_dn(ldap, e);
-		debug(LOGOPT_NONE, MODPREFIX "found query dn %s", dn);
+		debug(logopt, MODPREFIX "found query dn %s", dn);
 	} else {
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      MODPREFIX "query succeeded, no matches for %s",
 		      query);
 		ldap_msgfree(result);
@@ -373,7 +366,7 @@ static struct ldap_schema *alloc_common_schema(struct ldap_schema *s)
 	return schema;
 }
 
-static int find_query_dn(LDAP *ldap, struct lookup_context *ctxt)
+static int find_query_dn(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	struct ldap_schema *schema;
 	unsigned int i;
@@ -384,11 +377,10 @@ static int find_query_dn(LDAP *ldap, struct lookup_context *ctxt)
 	for (i = 0; i < common_schema_count; i++) {
 		const char *class = common_schema[i].map_class;
 		const char *key = common_schema[i].map_attr;
-		if (get_query_dn(ldap, ctxt, class, key)) {
+		if (get_query_dn(logopt, ldap, ctxt, class, key)) {
 			schema = alloc_common_schema(&common_schema[i]);
 			if (!schema) {
-				error(LOGOPT_ANY,
-				      MODPREFIX "failed to allocate schema");
+				error(logopt, MODPREFIX "failed to allocate schema");
 				return 0;
 			}
 			ctxt->schema = schema;
@@ -399,28 +391,26 @@ static int find_query_dn(LDAP *ldap, struct lookup_context *ctxt)
 	return 0;
 }
 
-static int do_bind(LDAP *ldap, struct lookup_context *ctxt)
+static int do_bind(unsigned logopt, LDAP *ldap, struct lookup_context *ctxt)
 {
 	char *host = NULL, *nhost;
 	int rv, need_base = 1;
 
 #ifdef WITH_SASL
-	debug(LOGOPT_NONE, "auth_required: %d, sasl_mech %s",
+	debug(logopt, MODPREFIX "auth_required: %d, sasl_mech %s",
 	      ctxt->auth_required, ctxt->sasl_mech);
 
 	if (ctxt->sasl_mech ||
 	   (ctxt->auth_required & (LDAP_AUTH_REQUIRED|LDAP_AUTH_AUTODETECT))) {
-		rv = autofs_sasl_bind(ldap, ctxt);
-		debug(LOGOPT_NONE, MODPREFIX
-		      "autofs_sasl_bind returned %d", rv);
+		rv = autofs_sasl_bind(logopt, ldap, ctxt);
+		debug(logopt, MODPREFIX "autofs_sasl_bind returned %d", rv);
 	} else {
-		rv = bind_ldap_anonymous(ldap, ctxt);
-		debug(LOGOPT_NONE,
-		      MODPREFIX "ldap anonymous bind returned %d", rv);
+		rv = bind_ldap_anonymous(logopt, ldap, ctxt);
+		debug(logopt, MODPREFIX "ldap anonymous bind returned %d", rv);
 	}
 #else
-	rv = bind_ldap_anonymous(ldap, ctxt);
-	debug(LOGOPT_NONE, MODPREFIX "ldap anonymous bind returned %d", rv);
+	rv = bind_ldap_anonymous(logopt, ldap, ctxt);
+	debug(logopt, MODPREFIX "ldap anonymous bind returned %d", rv);
 #endif
 
 	if (rv != 0)
@@ -428,13 +418,13 @@ static int do_bind(LDAP *ldap, struct lookup_context *ctxt)
 
 	rv = ldap_get_option(ldap, LDAP_OPT_HOST_NAME, &host);
         if (rv != LDAP_SUCCESS || !host) {
-		debug(LOGOPT_ANY, "failed to get hostname for connection");
+		debug(logopt, "failed to get hostname for connection");
 		return 0;
 	}
 
 	nhost = strdup(host);
 	if (!nhost) {
-		debug(LOGOPT_ANY, "failed to alloc context for hostname");
+		debug(logopt, "failed to alloc context for hostname");
 		return 0;
 	}
 	ldap_memfree(host);
@@ -463,16 +453,16 @@ static int do_bind(LDAP *ldap, struct lookup_context *ctxt)
 	 * base dn for searches.
 	 */
 	if (!ctxt->schema) {
-		if (!find_query_dn(ldap, ctxt)) {
-			error(LOGOPT_ANY,
-		      	      MODPREFIX "failed to find valid query dn");
+		if (!find_query_dn(logopt, ldap, ctxt)) {
+			warn(logopt,
+			      MODPREFIX "failed to find valid query dn");
 			return 0;
 		}
 	} else {
 		const char *class = ctxt->schema->map_class;
 		const char *key = ctxt->schema->map_attr;
-		if (!get_query_dn(ldap, ctxt, class, key)) {
-			error(LOGOPT_ANY, MODPREFIX "failed to get query dn");
+		if (!get_query_dn(logopt, ldap, ctxt, class, key)) {
+			error(logopt, MODPREFIX "failed to get query dn");
 			return 0;
 		}
 	}
@@ -480,23 +470,23 @@ static int do_bind(LDAP *ldap, struct lookup_context *ctxt)
 	return 1;
 }
 
-static LDAP *do_connect(const char *uri, struct lookup_context *ctxt)
+static LDAP *do_connect(unsigned logopt, const char *uri, struct lookup_context *ctxt)
 {
 	LDAP *ldap;
 
-	ldap = init_ldap_connection(uri, ctxt);
+	ldap = init_ldap_connection(logopt, uri, ctxt);
 	if (!ldap)
 		return NULL;
 
-	if (!do_bind(ldap, ctxt)) {
-		unbind_ldap_connection(ldap, ctxt);
+	if (!do_bind(logopt, ldap, ctxt)) {
+		unbind_ldap_connection(logopt, ldap, ctxt);
 		return NULL;
 	}
 
 	return ldap;
 }
 
-static LDAP *connect_to_server(const char *uri, struct lookup_context *ctxt)
+static LDAP *connect_to_server(unsigned logopt, const char *uri, struct lookup_context *ctxt)
 {
 	LDAP *ldap;
 
@@ -506,19 +496,19 @@ static LDAP *connect_to_server(const char *uri, struct lookup_context *ctxt)
 	 * authentication.
 	 */
 	if (ctxt->auth_required & LDAP_AUTH_REQUIRED) {
-		ldap = auth_init(uri, ctxt);
+		ldap = auth_init(logopt, uri, ctxt);
 		if (!ldap && ctxt->auth_required & LDAP_AUTH_AUTODETECT)
-			warn(LOGOPT_NONE,
+			info(logopt,
 			     "no authentication mechanisms auto detected.");
 		if (!ldap) {
-			error(LOGOPT_ANY, MODPREFIX
+			error(logopt, MODPREFIX
 			      "cannot initialize authentication setup");
 			return NULL;
 		}
 
-		if (!do_bind(ldap, ctxt)) {
-			unbind_ldap_connection(ldap, ctxt);
-			error(LOGOPT_ANY, MODPREFIX "cannot bind to server");
+		if (!do_bind(logopt, ldap, ctxt)) {
+			unbind_ldap_connection(logopt, ldap, ctxt);
+			error(logopt, MODPREFIX "cannot bind to server");
 			return NULL;
 		}
 
@@ -526,16 +516,18 @@ static LDAP *connect_to_server(const char *uri, struct lookup_context *ctxt)
 	}
 #endif
 
-	ldap = do_connect(uri, ctxt);
+	ldap = do_connect(logopt, uri, ctxt);
 	if (!ldap) {
-		error(LOGOPT_ANY, MODPREFIX "cannot connect to server");
+		warn(logopt,
+		     MODPREFIX "couldn't connect to server %s",
+		     uri ? uri : "default");
 		return NULL;
 	}
 
 	return ldap;
 }
 
-static LDAP *find_server(struct lookup_context *ctxt)
+static LDAP *find_server(unsigned logopt, struct lookup_context *ctxt)
 {
 	LDAP *ldap = NULL;
 	struct ldap_uri *this;
@@ -547,10 +539,9 @@ static LDAP *find_server(struct lookup_context *ctxt)
 	while(p != ctxt->uri) {
 		this = list_entry(p, struct ldap_uri, list);
 		p = p->next;
-		debug(LOGOPT_ANY, "check uri %s", this->uri);
-		ldap = connect_to_server(this->uri, ctxt);
+		ldap = connect_to_server(logopt, this->uri, ctxt);
 		if (ldap) {
-			debug(LOGOPT_ANY, "connexted to uri %s", this->uri);
+			info(logopt, "connected to uri %s", this->uri);
 			break;
 		}
 		list_del_init(&this->list);
@@ -568,17 +559,17 @@ static LDAP *find_server(struct lookup_context *ctxt)
 	return ldap;
 }
 
-static LDAP *do_reconnect(struct lookup_context *ctxt)
+static LDAP *do_reconnect(unsigned logopt, struct lookup_context *ctxt)
 {
 	LDAP *ldap;
 
 	if (ctxt->server || !ctxt->uri) {
-		ldap = do_connect(ctxt->server, ctxt);
+		ldap = do_connect(logopt, ctxt->server, ctxt);
 		return ldap;
 	} else {
 		struct ldap_uri *this;
 		this = list_entry(ctxt->uri->next, struct ldap_uri, list);
-		ldap = do_connect(this->uri, ctxt);
+		ldap = do_connect(logopt, this->uri, ctxt);
 		if (ldap)
 			return ldap;
 		/* Failed to connect, put at end of list */
@@ -589,15 +580,15 @@ static LDAP *do_reconnect(struct lookup_context *ctxt)
 	autofs_sasl_done(ctxt);
 
 	/* Current server failed connect, try the rest */
-	ldap = find_server(ctxt);
+	ldap = find_server(logopt, ctxt);
 	if (!ldap)
-		error(LOGOPT_ANY, MODPREFIX "failed to find available server");
+		error(logopt, MODPREFIX "failed to find available server");
 
 	return ldap;
 }
 
 #ifdef WITH_SASL
-int get_property(xmlNodePtr node, const char *prop, char **value)
+int get_property(unsigned logopt, xmlNodePtr node, const char *prop, char **value)
 {
 	xmlChar *ret;
 	xmlChar *property = (xmlChar *) prop;
@@ -608,8 +599,7 @@ int get_property(xmlNodePtr node, const char *prop, char **value)
 	}
 
 	if (!(*value = strdup((char *) ret))) {
-		error(LOGOPT_ANY,
-		      MODPREFIX "strdup failed with %d", errno);
+		logerr(MODPREFIX "strdup failed with %d", errno);
 		xmlFree(ret);
 		return -1;
 	}
@@ -645,7 +635,7 @@ int authtype_requires_creds(const char *authtype)
  *  then no further action is necessary.  If it is not, the caller is free
  *  to then use another method to determine how to connect to the server.
  */
-int parse_ldap_config(struct lookup_context *ctxt)
+int parse_ldap_config(unsigned logopt, struct lookup_context *ctxt)
 {
 	int          ret = 0, fallback = 0;
 	unsigned int auth_required = LDAP_AUTH_NOTREQUIRED;
@@ -662,7 +652,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 
 	auth_conf = (char *) defaults_get_auth_conf_file();
 	if (!auth_conf) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX "failed to get auth config file name.");
 		return 0;
 	}
@@ -687,7 +677,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 			ctxt->client_princ = NULL;
 			return 0;
 		}
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX "stat(2) failed with error %s.",
 		      strerror(errno));
 		return 0;
@@ -696,8 +686,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 	if (!S_ISREG(st.st_mode) ||
 	    st.st_uid != 0 || st.st_gid != 0 ||
 	    (st.st_mode & 0x01ff) != 0600) {
-		error(LOGOPT_ANY,
-		      MODPREFIX
+		error(logopt, MODPREFIX
 		      "Configuration file %s exists, but is not usable. "
 		      "Please make sure that it is owned by root, group "
 		      "is root, and the mode is 0600.",
@@ -708,30 +697,29 @@ int parse_ldap_config(struct lookup_context *ctxt)
 	xmlInitParser();
 	doc = xmlParseFile(auth_conf);
 	if (!doc) {
-		warn(LOGOPT_ANY,
-		     MODPREFIX "xmlParseFile failed for %s.", auth_conf);
+		error(logopt, MODPREFIX
+		     "xmlParseFile failed for %s.", auth_conf);
 		goto out;
 	}
 
 	root = xmlDocGetRootElement(doc);
 	if (!root) {
-		debug(LOGOPT_ANY,
-		      MODPREFIX "empty xml document (%s).", auth_conf);
+		debug(logopt, MODPREFIX
+		      "empty xml document (%s).", auth_conf);
 		fallback = 1;
 		goto out;
 	}
 
 	if (xmlStrcmp(root->name, (const xmlChar *)"autofs_ldap_sasl_conf")) {
-		error(LOGOPT_ANY,
-		      MODPREFIX
+		error(logopt, MODPREFIX
 		      "The root node of the XML document %s is not "
 		      "autofs_ldap_sasl_conf.", auth_conf);
 		goto out;
 	}
 
-	ret = get_property(root, "usetls", &usetls);
+	ret = get_property(logopt, root, "usetls", &usetls);
 	if (ret != 0) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX
 		      "Failed read the usetls property from "
 		      "the configuration file %s.", auth_conf);
@@ -746,7 +734,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 		else if (!strcasecmp(usetls, "no"))
 			use_tls = LDAP_TLS_DONT_USE;
 		else {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      MODPREFIX
 			      "The usetls property must have value "
 			      "\"yes\" or \"no\".");
@@ -756,9 +744,9 @@ int parse_ldap_config(struct lookup_context *ctxt)
 		free(usetls);
 	}
 
-	ret = get_property(root, "tlsrequired", &tlsrequired);
+	ret = get_property(logopt, root, "tlsrequired", &tlsrequired);
 	if (ret != 0) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX
 		      "Failed read the tlsrequired property from "
 		      "the configuration file %s.", auth_conf);
@@ -773,7 +761,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 		else if (!strcasecmp(tlsrequired, "no"))
 			tls_required = LDAP_TLS_DONT_USE;
 		else {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      MODPREFIX
 			      "The tlsrequired property must have value "
 			      "\"yes\" or \"no\".");
@@ -783,9 +771,9 @@ int parse_ldap_config(struct lookup_context *ctxt)
 		free(tlsrequired);
 	}
 
-	ret = get_property(root, "authrequired", &authrequired);
+	ret = get_property(logopt, root, "authrequired", &authrequired);
 	if (ret != 0) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX
 		      "Failed read the authrequired property from "
 		      "the configuration file %s.", auth_conf);
@@ -802,7 +790,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 		else if (!strcasecmp(authrequired, "autodetect"))
 			auth_required = LDAP_AUTH_AUTODETECT;
 		else {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      MODPREFIX
 			      "The authrequired property must have value "
 			      "\"yes\", \"no\" or \"autodetect\".");
@@ -812,9 +800,9 @@ int parse_ldap_config(struct lookup_context *ctxt)
 		free(authrequired);
 	}
 
-	ret = get_property(root, "authtype", &authtype);
+	ret = get_property(logopt, root, "authtype", &authtype);
 	if (ret != 0) {
-		error(LOGOPT_ANY,
+		error(logopt,
 		      MODPREFIX
 		      "Failed read the authtype property from the "
 		      "configuration file %s.", auth_conf);
@@ -822,10 +810,10 @@ int parse_ldap_config(struct lookup_context *ctxt)
 	}
 
 	if (authtype && authtype_requires_creds(authtype)) {
-		ret = get_property(root, "user",  &user);
-		ret |= get_property(root, "secret", &secret);
+		ret = get_property(logopt, root, "user",  &user);
+		ret |= get_property(logopt, root, "secret", &secret);
 		if (ret != 0 || (!user || !secret)) {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      MODPREFIX
 			      "%s authentication type requires a username "
 			      "and a secret.  Please fix your configuration "
@@ -845,7 +833,7 @@ int parse_ldap_config(struct lookup_context *ctxt)
 	 * We allow the admin to specify the principal to use for the
 	 * client.  The default is "autofsclient/hostname@REALM".
 	 */
-	(void)get_property(root, "clientprinc", &client_princ);
+	(void)get_property(logopt, root, "clientprinc", &client_princ);
 
 	ctxt->auth_conf = auth_conf;
 	ctxt->use_tls = use_tls;
@@ -856,15 +844,15 @@ int parse_ldap_config(struct lookup_context *ctxt)
 	ctxt->secret = secret;
 	ctxt->client_princ = client_princ;
 
-	debug(LOGOPT_NONE,
+	debug(logopt, MODPREFIX
 	      "ldap authentication configured with the following options:");
-	debug(LOGOPT_NONE,
+	debug(logopt, MODPREFIX
 	      "use_tls: %u, "
 	      "tls_required: %u, "
 	      "auth_required: %u, "
 	      "sasl_mech: %s",
 	      use_tls, tls_required, auth_required, authtype);
-	debug(LOGOPT_NONE,
+	debug(logopt, MODPREFIX
 	      "user: %s, "
 	      "secret: %s, "
 	      "client principal: %s",
@@ -889,7 +877,7 @@ out:
  *  Returns ldap connection on success, with authtype, user and secret
  *  filled in as appropriate.  Returns NULL on failre.
  */
-static LDAP *auth_init(const char *uri, struct lookup_context *ctxt)
+static LDAP *auth_init(unsigned logopt, const char *uri, struct lookup_context *ctxt)
 {
 	int ret;
 	LDAP *ldap;
@@ -900,11 +888,11 @@ static LDAP *auth_init(const char *uri, struct lookup_context *ctxt)
 	 *  if the permissions on the file were incorrect, or if the
 	 *  specified authentication type is not valid.
 	 */
-	ret = parse_ldap_config(ctxt);
+	ret = parse_ldap_config(logopt, ctxt);
 	if (ret)
 		return NULL;
 
-	ldap = init_ldap_connection(uri, ctxt);
+	ldap = init_ldap_connection(logopt, uri, ctxt);
 	if (!ldap)
 		return NULL;
 
@@ -916,7 +904,7 @@ static LDAP *auth_init(const char *uri, struct lookup_context *ctxt)
 	 *  to use. If kerberos is used, it will also take care to initialize
 	 *  the credential cache and the client and service principals.
 	 */
-	ret = autofs_sasl_init(ldap, ctxt);
+	ret = autofs_sasl_init(logopt, ldap, ctxt);
 	if (ret) {
 		ctxt->sasl_mech = NULL;
 		return NULL;
@@ -930,7 +918,7 @@ static LDAP *auth_init(const char *uri, struct lookup_context *ctxt)
  *  Take an input string as specified in the master map, and break it
  *  down into a server name and basedn.
  */
-static int parse_server_string(const char *url, struct lookup_context *ctxt)
+static int parse_server_string(unsigned logopt, const char *url, struct lookup_context *ctxt)
 {
 	char buf[MAX_ERR_BUF], *tmp = NULL, proto[9];
 	const char *ptr, *name;
@@ -939,8 +927,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 	memset(proto, 0, 9);
 	ptr = url;
 
-	debug(LOGOPT_NONE,
-	      MODPREFIX
+	debug(logopt, MODPREFIX
 	      "Attempting to parse LDAP information from string \"%s\".", ptr);
 
 	ctxt->port = LDAP_PORT;
@@ -974,7 +961,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 			if (!tmp) {
 				char *estr;
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+				logerr(MODPREFIX "malloc: %s", estr);
 				return 0;
 			}
 			ctxt->server = tmp;
@@ -987,7 +974,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 				memcpy(ctxt->server, s, l);
 			ptr = q + 1;
 		} else {
-			crit(LOGOPT_ANY,
+			crit(logopt,
 			     MODPREFIX "invalid LDAP map syntax %s", ptr);
 			return 0;
 /* TODO: why did I put this here, the parser shouldn't let this by
@@ -996,7 +983,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 			if (!tmp) {
 				char *estr;
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+				crit(logopt, MODPREFIX "malloc: %s", estr);
 				return 0;
 			}
 			ctxt->server = tmp;
@@ -1014,7 +1001,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 				q++;
 
 		if (*q != ':') {
-			crit(LOGOPT_ANY,
+			crit(logopt,
 			     MODPREFIX "invalid LDAP map syntax %s", ptr);
 			return 0;
 		}
@@ -1031,7 +1018,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 		if (!tmp) {
 			char *estr;
 			estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+			logerr(MODPREFIX "malloc: %s", estr);
 			return 0;
 		}
 		ctxt->server = tmp;
@@ -1072,7 +1059,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 			else {
 				char *estr;
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+				logerr(MODPREFIX "malloc: %s", estr);
 				if (ctxt->server)
 					free(ctxt->server);
 				return 0;
@@ -1083,7 +1070,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 			if (!base) {
 				char *estr;
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+				logerr(MODPREFIX "malloc: %s", estr);
 				if (ctxt->server)
 					free(ctxt->server);
 				return 0;
@@ -1097,7 +1084,7 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 		if (!map) {
 			char *estr;
 			estr = strerror_r(errno, buf, MAX_ERR_BUF);
-			crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+			logerr(MODPREFIX "malloc: %s", estr);
 			if (ctxt->server)
 				free(ctxt->server);
 			return 0;
@@ -1109,16 +1096,16 @@ static int parse_server_string(const char *url, struct lookup_context *ctxt)
 
 	if (!ctxt->server && *proto) {
 		if (!strncmp(proto, "ldaps", 5)) {
-			warn(LOGOPT_ANY, MODPREFIX
+			info(logopt, MODPREFIX
 			     "server must be given to force ldaps, connection "
 			     "will use LDAP client configured protocol");
 		}
 	}
 done:
 	if (ctxt->mapname)
-		debug(LOGOPT_NONE, MODPREFIX "mapname %s", ctxt->mapname);
+		debug(logopt, MODPREFIX "mapname %s", ctxt->mapname);
 	else
-		debug(LOGOPT_NONE, MODPREFIX "server \"%s\", base dn \"%s\"",
+		debug(logopt, MODPREFIX "server \"%s\", base dn \"%s\"",
 			ctxt->server ? ctxt->server : "(default)",
 			ctxt->base);
 
@@ -1175,8 +1162,6 @@ static void validate_uris(struct list_head *list)
 
 		/* At least we get some basic validation */
 		if (!ldap_is_ldap_url(this->uri)) {
-			warn(LOGOPT_ANY,
-			     "removed invalid uri from list, %s", this->uri);
 			list_del(&this->list);
 			free(this->uri);
 			free(this);
@@ -1202,7 +1187,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return 1;
 	}
 	memset(ctxt, 0, sizeof(struct lookup_context));
@@ -1215,7 +1200,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	 * Parse out the server name and base dn, and fill them
 	 * into the proper places in the lookup context structure.
 	 */
-	if (!parse_server_string(argv[0], ctxt)) {
+	if (!parse_server_string(LOGOPT_NONE, argv[0], ctxt)) {
 		error(LOGOPT_ANY, MODPREFIX "cannot parse server string");
 		free_context(ctxt);
 		return 1;
@@ -1236,13 +1221,13 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	}
 
 	if (ctxt->server || !ctxt->uri) {
-		ldap = connect_to_server(ctxt->server, ctxt);
+		ldap = connect_to_server(LOGOPT_NONE, ctxt->server, ctxt);
 		if (!ldap) {
 			free_context(ctxt);
 			return 1;
 		}
 	} else {
-		ldap = find_server(ctxt);
+		ldap = find_server(LOGOPT_NONE, ctxt);
 		if (!ldap) {
 			free_context(ctxt);
 			error(LOGOPT_ANY, MODPREFIX
@@ -1250,13 +1235,13 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 			return 1;
 		}
 	}
-	unbind_ldap_connection(ldap, ctxt);
+	unbind_ldap_connection(LOGOPT_ANY, ldap, ctxt);
 
 	/* Open the parser, if we can. */
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
 	if (!ctxt->parse) {
 		free_context(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logerr(MODPREFIX "failed to open parse context");
 		return 1;
 	}
 	*context = ctxt;
@@ -1269,6 +1254,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	unsigned int timeout = master->default_timeout;
 	unsigned int logging = master->default_logging;
+	unsigned int logopt = master->logopt;
 	int rv, l, count, blen;
 	char buf[PARSE_MAX_BUF];
 	char *query;
@@ -1293,45 +1279,44 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	query = alloca(l);
 	if (query == NULL) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		return NSS_STATUS_UNAVAIL;
 	}
 
 	if (sprintf(query, "(objectclass=%s)", class) >= l) {
-		debug(LOGOPT_NONE, MODPREFIX "error forming query string");
+		error(logopt, MODPREFIX "error forming query string");
 		return NSS_STATUS_UNAVAIL;
 	}
 	query[l] = '\0';
 
 	/* Initialize the LDAP context. */
-	ldap = do_reconnect(ctxt);
+	ldap = do_reconnect(logopt, ctxt);
 	if (!ldap)
 		return NSS_STATUS_UNAVAIL;
 
 	/* Look around. */
-	debug(LOGOPT_NONE,
+	debug(logopt,
 	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
 
 	rv = ldap_search_s(ldap, ctxt->qdn, scope, query, attrs, 0, &result);
 
 	if ((rv != LDAP_SUCCESS) || !result) {
-		error(LOGOPT_NONE,
-		      MODPREFIX "query failed for %s: %s",
+		error(logopt, MODPREFIX "query failed for %s: %s",
 		      query, ldap_err2string(rv));
-		unbind_ldap_connection(ldap, ctxt);
+		unbind_ldap_connection(logging, ldap, ctxt);
 		return NSS_STATUS_NOTFOUND;
 	}
 
 	e = ldap_first_entry(ldap, result);
 	if (!e) {
-		debug(LOGOPT_NONE,
+		debug(logopt,
 		      MODPREFIX "query succeeded, no matches for %s",
 		      query);
 		ldap_msgfree(result);
-		unbind_ldap_connection(ldap, ctxt);
+		unbind_ldap_connection(logging, ldap, ctxt);
 		return NSS_STATUS_NOTFOUND;
 	} else
-		debug(LOGOPT_NONE, MODPREFIX "examining entries");
+		debug(logopt, MODPREFIX "examining entries");
 
 	while (e) {
 		keyValue = ldap_get_values(ldap, e, entry);
@@ -1346,7 +1331,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		 * each map entry
 		 */
 		if (ldap_count_values(keyValue) > 1) {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      MODPREFIX
 			      "key %s has duplicate entries - ignoring",
 			      *keyValue);
@@ -1358,7 +1343,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		 * inclusion is only valid in file maps.
 		 */
 		if (**keyValue == '+') {
-			warn(LOGOPT_ANY,
+			warn(logopt,
 			     MODPREFIX
 			     "ignoreing '+' map entry - not in file map");
 			goto next;
@@ -1366,7 +1351,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 
 		values = ldap_get_values(ldap, e, info);
 		if (!values || !*values) {
-			debug(LOGOPT_NONE,
+			debug(logopt,
 			      MODPREFIX "no %s defined for %s", info, query);
 			goto next;
 		}
@@ -1376,7 +1361,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		 */
 		count = ldap_count_values(values);
 		if (count > 1) {
-			error(LOGOPT_ANY,
+			error(logopt,
 			      MODPREFIX
 			      "one value per key allowed in master map");
 			ldap_value_free(values);
@@ -1385,7 +1370,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 
 		blen = strlen(*keyValue) + 1 + strlen(*values) + 1;
 		if (blen > PARSE_MAX_BUF) {
-			error(LOGOPT_ANY, MODPREFIX "map entry too long");
+			error(logopt, MODPREFIX "map entry too long");
 			ldap_value_free(values);
 			goto next;
 		}
@@ -1403,7 +1388,7 @@ next:
 
 	/* Clean up. */
 	ldap_msgfree(result);
-	unbind_ldap_connection(ldap, ctxt);
+	unbind_ldap_connection(logopt, ldap, ctxt);
 
 	return NSS_STATUS_SUCCESS;
 }
@@ -1445,7 +1430,7 @@ static int read_one_map(struct autofs_point *ap,
 	query = alloca(l);
 	if (query == NULL) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return NSS_STATUS_UNAVAIL;
 	}
 
@@ -1456,7 +1441,7 @@ static int read_one_map(struct autofs_point *ap,
 	query[l] = '\0';
 
 	/* Initialize the LDAP context. */
-	ldap = do_reconnect(ctxt);
+	ldap = do_reconnect(ap->logopt, ctxt);
 	if (!ldap)
 		return NSS_STATUS_UNAVAIL;
 
@@ -1470,7 +1455,7 @@ static int read_one_map(struct autofs_point *ap,
 		debug(ap->logopt,
 		      MODPREFIX "query failed for %s: %s",
 		      query, ldap_err2string(rv));
-		unbind_ldap_connection(ldap, ctxt);
+		unbind_ldap_connection(ap->logopt, ldap, ctxt);
 		*result_ldap = rv;
 		return NSS_STATUS_NOTFOUND;
 	}
@@ -1480,7 +1465,7 @@ static int read_one_map(struct autofs_point *ap,
 		debug(ap->logopt,
 		      MODPREFIX "query succeeded, no matches for %s", query);
 		ldap_msgfree(result);
-		unbind_ldap_connection(ldap, ctxt);
+		unbind_ldap_connection(ap->logopt, ldap, ctxt);
 		return NSS_STATUS_NOTFOUND;
 	} else
 		debug(ap->logopt, MODPREFIX "examining entries");
@@ -1612,8 +1597,7 @@ static int read_one_map(struct autofs_point *ap,
 				if (!mapent) {
 					char *estr;
 					estr = strerror_r(errno, buf, MAX_ERR_BUF);
-					error(ap->logopt,
-					      MODPREFIX "malloc: %s", estr);
+					logerr(MODPREFIX "malloc: %s", estr);
 					ldap_value_free_len(bvValues);
 					goto next;
 				}
@@ -1633,8 +1617,7 @@ static int read_one_map(struct autofs_point *ap,
 				} else {
 					char *estr;
 					estr = strerror_r(errno, buf, MAX_ERR_BUF);
-					error(ap->logopt,
-					      MODPREFIX "realloc: %s", estr);
+					logerr(MODPREFIX "realloc: %s", estr);
 				}
 			}
 		}
@@ -1669,7 +1652,7 @@ next:
 
 	/* Clean up. */
 	ldap_msgfree(result);
-	unbind_ldap_connection(ldap, ctxt);
+	unbind_ldap_connection(ap->logopt, ldap, ctxt);
 
 	source->age = age;
 
@@ -1766,7 +1749,7 @@ static int lookup_one(struct autofs_point *ap,
 	query[ql] = '\0';
 
 	/* Initialize the LDAP context. */
-	ldap = do_reconnect(ctxt);
+	ldap = do_reconnect(ap->logopt, ctxt);
 	if (!ldap)
 		return CHE_FAIL;
 
@@ -1777,7 +1760,7 @@ static int lookup_one(struct autofs_point *ap,
 
 	if ((rv != LDAP_SUCCESS) || !result) {
 		crit(ap->logopt, MODPREFIX "query failed for %s", query);
-		unbind_ldap_connection(ldap, ctxt);
+		unbind_ldap_connection(ap->logopt, ldap, ctxt);
 		return CHE_FAIL;
 	}
 
@@ -1789,7 +1772,7 @@ static int lookup_one(struct autofs_point *ap,
 		debug(ap->logopt,
 		     MODPREFIX "got answer, but no entry for %s", query);
 		ldap_msgfree(result);
-		unbind_ldap_connection(ldap, ctxt);
+		unbind_ldap_connection(ap->logopt, ldap, ctxt);
 		return CHE_MISSING;
 	}
 
@@ -1897,8 +1880,7 @@ static int lookup_one(struct autofs_point *ap,
 				if (!mapent) {
 					char *estr;
 					estr = strerror_r(errno, buf, MAX_ERR_BUF);
-					error(ap->logopt,
-					      MODPREFIX "malloc: %s", estr);
+					logerr(MODPREFIX "malloc: %s", estr);
 					ldap_value_free_len(bvValues);
 					goto next;
 				}
@@ -1918,8 +1900,7 @@ static int lookup_one(struct autofs_point *ap,
 				} else {
 					char *estr;
 					estr = strerror_r(errno, buf, MAX_ERR_BUF);
-					error(ap->logopt,
-					      MODPREFIX "realloc: %s", estr);
+					logerr(MODPREFIX "realloc: %s", estr);
 				}
 			}
 		}
@@ -1955,7 +1936,7 @@ next:
 	}
 
 	ldap_msgfree(result);
-	unbind_ldap_connection(ldap, ctxt);
+	unbind_ldap_connection(ap->logopt, ldap, ctxt);
 
 	/* Failed to find wild entry, update cache if needed */
 	pthread_cleanup_push(cache_lock_cleanup, mc);
diff --git a/modules/lookup_multi.c b/modules/lookup_multi.c
index 8fa94ae..601d48e 100644
--- a/modules/lookup_multi.c
+++ b/modules/lookup_multi.c
@@ -73,7 +73,7 @@ static struct lookup_mod *nss_open_lookup(const char *format, int argc, const ch
 	if (nsswitch_parse(&nsslist)) {
 		if (!list_empty(&nsslist))
 			free_sources(&nsslist);
-		error(LOGOPT_ANY, "can't to read name service switch config.");
+		logerr("can't to read name service switch config.");
 		return NULL;
 	}
 
@@ -92,7 +92,7 @@ static struct lookup_mod *nss_open_lookup(const char *format, int argc, const ch
 			path = malloc(strlen(AUTOFS_MAP_DIR) + strlen(argv[0]) + 2);
 			if (!path) {
 				estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				crit(LOGOPT_ANY, MODPREFIX "error: %s", estr);
+				logerr(MODPREFIX "error: %s", estr);
 				free_sources(&nsslist);
 				return NULL;
 			}
@@ -150,7 +150,7 @@ int lookup_init(const char *my_mapfmt, int argc, const char *const *argv, void *
 	memset(ctxt, 0, sizeof(struct lookup_context));
 
 	if (argc < 1) {
-		crit(LOGOPT_ANY, MODPREFIX "No map list");
+		logerr(MODPREFIX "No map list");
 		goto error_out;
 	}
 
@@ -176,8 +176,7 @@ int lookup_init(const char *my_mapfmt, int argc, const char *const *argv, void *
 		if (!strcmp(ctxt->argl[an], "--")) {
 			ctxt->argl[an] = NULL;
 			if (!args) {
-				crit(LOGOPT_ANY,
-				     MODPREFIX "error assigning map args");
+				logerr(MODPREFIX "error assigning map args");
 				goto error_out;
 			}
 			ctxt->m[i].argv = copy_argv(ctxt->m[i].argc, (const char **) args);
@@ -201,7 +200,7 @@ int lookup_init(const char *my_mapfmt, int argc, const char *const *argv, void *
 		ctxt->m[i].mod = nss_open_lookup(my_mapfmt,
 				 ctxt->m[i].argc, ctxt->m[i].argv);
 		if (!ctxt->m[i].mod) {
-			error(LOGOPT_ANY, MODPREFIX "error opening module");
+			logerr(MODPREFIX "error opening module");
 			goto error_out;
 		}
 	}
@@ -211,7 +210,7 @@ int lookup_init(const char *my_mapfmt, int argc, const char *const *argv, void *
 
 nomem:
 	estr = strerror_r(errno, buf, MAX_ERR_BUF);
-	crit(LOGOPT_ANY, MODPREFIX "error: %s", estr);
+	logerr(MODPREFIX "error: %s", estr);
 error_out:
 	if (ctxt) {
 		for (i = 0; i < ctxt->n; i++) {
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index 83e99e0..ff8bd49 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -41,13 +41,13 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "%s", estr);
+		logerr(MODPREFIX "%s", estr);
 		return 1;
 	}
 
 	if (argc < 1) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "No map name");
+		logmsg(MODPREFIX "No map name");
 		return 1;
 	}
 	ctxt->mapname = argv[0];
@@ -59,7 +59,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt->domainname = nis_local_directory();
 	if (!ctxt->domainname) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "NIS+ domain not set");
+		logmsg(MODPREFIX "NIS+ domain not set");
 		return 1;
 	}
 
@@ -69,7 +69,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
 	if (!ctxt->parse) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logerr(MODPREFIX "failed to open parse context");
 		return 1;
 	}
 	*context = ctxt;
@@ -81,7 +81,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 {
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	unsigned int timeout = master->default_timeout;
-	unsigned int logging =  master->default_logging;
+	unsigned int logging = master->default_logging;
+	unsigned int logopt =  master->logopt;
 	char *tablename;
 	nis_result *result;
 	nis_object *this;
@@ -95,7 +96,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	tablename = alloca(strlen(ctxt->mapname) + strlen(ctxt->domainname) + 20);
 	if (!tablename) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		pthread_setcancelstate(cur_state, NULL);
 		return NSS_STATUS_UNAVAIL;
 	}
@@ -105,8 +106,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	result = nis_lookup(tablename, FOLLOW_PATH | FOLLOW_LINKS);
 	if (result->status != NIS_SUCCESS && result->status != NIS_S_SUCCESS) {
 		nis_freeresult(result);
-		crit(LOGOPT_ANY,
-		     MODPREFIX "couldn't locat nis+ table %s", ctxt->mapname);
+		crit(logopt,
+		     MODPREFIX "couldn't locate nis+ table %s", ctxt->mapname);
 		pthread_setcancelstate(cur_state, NULL);
 		return NSS_STATUS_NOTFOUND;
 	}
@@ -116,7 +117,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	result = nis_list(tablename, FOLLOW_PATH | FOLLOW_LINKS, NULL, NULL);
 	if (result->status != NIS_SUCCESS && result->status != NIS_S_SUCCESS) {
 		nis_freeresult(result);
-		crit(LOGOPT_ANY,
+		crit(logopt,
 		     MODPREFIX "couldn't enumrate nis+ map %s", ctxt->mapname);
 		pthread_setcancelstate(cur_state, NULL);
 		return NSS_STATUS_UNAVAIL;
@@ -139,8 +140,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 
 		buffer = malloc(ENTRY_LEN(this, 0) + 1 + ENTRY_LEN(this, 1) + 1);
 		if (!buffer) {
-			error(LOGOPT_ANY,
-			      MODPREFIX "could not malloc parse buffer");
+			logerr(MODPREFIX "could not malloc parse buffer");
 			continue;
 		}
 
@@ -182,7 +182,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	tablename = alloca(strlen(ctxt->mapname) + strlen(ctxt->domainname) + 20);
 	if (!tablename) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		pthread_setcancelstate(cur_state, NULL);
 		return NSS_STATUS_UNAVAIL;
 	}
@@ -193,7 +193,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	if (result->status != NIS_SUCCESS && result->status != NIS_S_SUCCESS) {
 		nis_freeresult(result);
 		crit(ap->logopt,
-		     MODPREFIX "couldn't locat nis+ table %s", ctxt->mapname);
+		     MODPREFIX "couldn't locate nis+ table %s", ctxt->mapname);
 		pthread_setcancelstate(cur_state, NULL);
 		return NSS_STATUS_NOTFOUND;
 	}
@@ -274,7 +274,7 @@ static int lookup_one(struct autofs_point *ap,
 			strlen(ctxt->mapname) + strlen(ctxt->domainname) + 20);
 	if (!tablename) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		pthread_setcancelstate(cur_state, NULL);
 		return -1;
 	}
@@ -327,7 +327,7 @@ static int lookup_wild(struct autofs_point *ap, struct lookup_context *ctxt)
 	tablename = alloca(strlen(ctxt->mapname) + strlen(ctxt->domainname) + 20);
 	if (!tablename) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		pthread_setcancelstate(cur_state, NULL);
 		return -1;
 	}
diff --git a/modules/lookup_program.c b/modules/lookup_program.c
index 2fd521a..e28168e 100644
--- a/modules/lookup_program.c
+++ b/modules/lookup_program.c
@@ -51,28 +51,26 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return 1;
 	}
 
 	if (argc < 1) {
-		crit(LOGOPT_ANY, MODPREFIX "No map name");
+		logmsg(MODPREFIX "No map name");
 		free(ctxt);
 		return 1;
 	}
 	ctxt->mapname = argv[0];
 
 	if (ctxt->mapname[0] != '/') {
-		crit(LOGOPT_ANY,
-		     MODPREFIX "program map %s is not an absolute pathname",
+		logmsg(MODPREFIX "program map %s is not an absolute pathname",
 		     ctxt->mapname);
 		free(ctxt);
 		return 1;
 	}
 
 	if (access(ctxt->mapname, X_OK)) {
-		crit(LOGOPT_ANY,
-		     MODPREFIX "program map %s missing or not executable",
+		logmsg(MODPREFIX "program map %s missing or not executable",
 		     ctxt->mapname);
 		free(ctxt);
 		return 1;
@@ -83,7 +81,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
 	if (!ctxt->parse) {
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logmsg(MODPREFIX "failed to open parse context");
 		free(ctxt);
 		return 1;
 	}
@@ -163,7 +161,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	mapent = (char *) malloc(MAPENT_MAX_LEN + 1);
 	if (!mapent) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return NSS_STATUS_UNAVAIL;
 	}
 
@@ -176,7 +174,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 */
 	if (pipe(pipefd)) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "pipe: %s", estr);
+		logerr(MODPREFIX "pipe: %s", estr);
 		goto out_free;
 	}
 	if (pipe(epipefd)) {
@@ -188,7 +186,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	f = fork();
 	if (f < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "fork: %s", estr);
+		logerr(MODPREFIX "fork: %s", estr);
 		close(pipefd[0]);
 		close(pipefd[1]);
 		close(epipefd[0]);
@@ -271,8 +269,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 						       ++alloci));
 					if (!tmp) {
 						alloci--;
-						error(ap->logopt,
-						      MODPREFIX "realloc: %s",
+						logerr(MODPREFIX "realloc: %s",
 						      strerror(errno));
 						break;
 					}
@@ -308,12 +305,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 			} else if (ch == '\n') {
 				*errp = '\0';
 				if (errbuf[0])
-					error(ap->logopt, ">> %s", errbuf);
+					logmsg(">> %s", errbuf);
 				errp = errbuf;
 			} else {
 				if (errp >= &errbuf[1023]) {
 					*errp = '\0';
-					error(ap->logopt, ">> %s", errbuf);
+					logmsg(">> %s", errbuf);
 					errp = errbuf;
 				}
 				*(errp++) = ch;
@@ -325,7 +322,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		*mapp = '\0';
 	if (errp > errbuf) {
 		*errp = '\0';
-		error(ap->logopt, ">> %s", errbuf);
+		logmsg(">> %s", errbuf);
 	}
 
 	close(pipefd[0]);
@@ -333,12 +330,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	if (waitpid(f, &status, 0) != f) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "waitpid: %s", estr);
+		logerr(MODPREFIX "waitpid: %s", estr);
 		goto out_free;
 	}
 
 	if (mapp == mapent || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {
-		msg(MODPREFIX "lookup for %s failed", name);
+		info(ap->logopt, MODPREFIX "lookup for %s failed", name);
 		goto out_free;
 	}
 
diff --git a/modules/lookup_userhome.c b/modules/lookup_userhome.c
index efcab0b..680ddaf 100644
--- a/modules/lookup_userhome.c
+++ b/modules/lookup_userhome.c
@@ -73,7 +73,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	/* Create the appropriate symlink */
 	if (chdir(ap->path)) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "chdir failed: %s", estr);
+		logerr(MODPREFIX "chdir failed: %s", estr);
 		return NSS_STATUS_UNAVAIL;
 	}
 
@@ -88,7 +88,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	if (symlink(pw->pw_dir, name) && errno != EEXIST) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "symlink failed: %s", estr);
+		logerr(MODPREFIX "symlink failed: %s", estr);
 		return NSS_STATUS_UNAVAIL;
 	}
 
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index da280cc..63fc8e3 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -45,12 +45,14 @@ struct lookup_context {
 struct callback_master_data {
 	unsigned timeout;
 	unsigned logging;
+	unsigned logopt;
 	time_t age;
 };
 
 struct callback_data {
 	struct autofs_point *ap;
 	struct map_source *source;
+	unsigned logopt;
 	time_t age;
 };
 
@@ -111,20 +113,18 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt = malloc(sizeof(struct lookup_context));
 	if (!ctxt) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "%s", estr);
+		logerr(MODPREFIX "%s", estr);
 		return 1;
 	}
 	memset(ctxt, 0, sizeof(struct lookup_context));
 
 	if (argc < 1) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "no map name");
+		logerr(MODPREFIX "no map name");
 		return 1;
 	}
 	ctxt->mapname = argv[0];
 
-	debug(LOGOPT_NONE, MODPREFIX "ctxt->mapname=%s", ctxt->mapname);
-
 	/* This should, but doesn't, take a const char ** */
 	err = yp_get_default_domain((char **) &ctxt->domainname);
 	if (err) {
@@ -133,8 +133,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 		memcpy(name, ctxt->mapname, len);
 		name[len] = '\0';
 		free(ctxt);
-		debug(LOGOPT_NONE, MODPREFIX "map %s: %s", name,
-		       yperr_string(err));
+		logerr(MODPREFIX "map %s: %s", name, yperr_string(err));
 		return 1;
 	}
 
@@ -146,7 +145,7 @@ int lookup_init(const char *mapfmt, int argc, const char *const *argv, void **co
 	ctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);
 	if (!ctxt->parse) {
 		free(ctxt);
-		crit(LOGOPT_ANY, MODPREFIX "failed to open parse context");
+		logmsg(MODPREFIX "failed to open parse context");
 		return 1;
 	}
 	*context = ctxt;
@@ -161,6 +160,7 @@ int yp_all_master_callback(int status, char *ypkey, int ypkeylen,
 			(struct callback_master_data *) ypcb_data;
 	unsigned int timeout = cbdata->timeout;
 	unsigned int logging = cbdata->logging;
+	unsigned int logopt = cbdata->logopt;
 	time_t age = cbdata->age;
 	char *buffer;
 	unsigned int len;
@@ -182,7 +182,7 @@ int yp_all_master_callback(int status, char *ypkey, int ypkeylen,
 
 	buffer = alloca(len);
 	if (!buffer) {
-		error(LOGOPT_ANY, MODPREFIX "could not malloc parse buffer");
+		error(logopt, MODPREFIX "could not malloc parse buffer");
 		return 0;
 	}
 	memset(buffer, 0, len);
@@ -201,6 +201,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	struct ypall_callback ypcb;
 	struct callback_master_data ypcb_data;
+	unsigned int logging = master->default_logging;
+	unsigned int logopt = master->logopt;
 	char *mapname;
 	int err;
 
@@ -211,7 +213,8 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	strcpy(mapname, ctxt->mapname);
 
 	ypcb_data.timeout = master->default_timeout;
-	ypcb_data.logging = master->default_logging;
+	ypcb_data.logging = logging;
+	ypcb_data.logopt = logopt;
 	ypcb_data.age = age;
 
 	ypcb.foreach = yp_all_master_callback;
@@ -232,7 +235,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		if (err == YPERR_SUCCESS)
 			return NSS_STATUS_SUCCESS;
 
-		warn(LOGOPT_ANY,
+		info(logopt,
 		     MODPREFIX "read of master map %s failed: %s",
 		     mapname, yperr_string(err));
 
@@ -249,6 +252,7 @@ int yp_all_callback(int status, char *ypkey, int ypkeylen,
 	struct autofs_point *ap = cbdata->ap;
 	struct map_source *source = cbdata->source;
 	struct mapent_cache *mc = source->mc;
+	unsigned int logopt = cbdata->logopt;
 	time_t age = cbdata->age;
 	char *key, *mapent;
 	int ret;
@@ -264,8 +268,10 @@ int yp_all_callback(int status, char *ypkey, int ypkeylen,
 		return 0;
 
 	key = sanitize_path(ypkey, ypkeylen, ap->type, ap->logopt);
-	if (!key)
+	if (!key) {
+		error(logopt, MODPREFIX "invalid path %s", ypkey);
 		return 0;
+	}
 
 	mapent = alloca(vallen + 1);
 	strncpy(mapent, val, vallen);
@@ -288,6 +294,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	struct lookup_context *ctxt = (struct lookup_context *) context;
 	struct ypall_callback ypcb;
 	struct callback_data ypcb_data;
+	unsigned int logopt = ap->logopt;
 	struct map_source *source;
 	char *mapname;
 	int err;
@@ -298,6 +305,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 
 	ypcb_data.ap = ap;
 	ypcb_data.source = source;
+	ypcb_data.logopt = logopt;
 	ypcb_data.age = age;
 
 	ypcb.foreach = yp_all_callback;
diff --git a/modules/mount_autofs.c b/modules/mount_autofs.c
index c45b91b..356fb14 100644
--- a/modules/mount_autofs.c
+++ b/modules/mount_autofs.c
@@ -64,7 +64,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 	fullpath = alloca(strlen(root) + name_len + 2);
 	if (!fullpath) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		return 1;
 	}
 
@@ -156,7 +156,6 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 	}
 	nap = entry->ap;
 	nap->parent = ap;
-	set_mnt_logging(nap);
 
 	argc = 1;
 
@@ -208,7 +207,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name,
 		return 1;
 	}
 
-	source->mc = cache_init(source);
+	source->mc = cache_init(entry->ap, source);
 	if (!source->mc) {
 		error(ap->logopt, MODPREFIX "failed to init source cache");
 		master_free_mapent(entry);
diff --git a/modules/mount_bind.c b/modules/mount_bind.c
index cb17ce4..04284f5 100644
--- a/modules/mount_bind.c
+++ b/modules/mount_bind.c
@@ -52,16 +52,14 @@ int mount_init(void **context)
 	if (lstat(t1_dir, &st1) == -1)
 		goto out;
 
-	err = spawn_mount(log_debug, "-n", "--bind", t1_dir, t2_dir, NULL);
+	err = spawn_mount(LOGOPT_NONE, "-n", "--bind", t1_dir, t2_dir, NULL);
 	if (err == 0 &&
 	    lstat(t2_dir, &st2) == 0 &&
 	    st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino) {
 		bind_works = 1;
 	}
 
-	debug(LOGOPT_NONE, MODPREFIX "bind_works = %d", bind_works);
-
-	spawn_umount(log_debug, "-n", t2_dir, NULL);
+	spawn_umount(LOGOPT_NONE, "-n", t2_dir, NULL);
 
 out:
 	rmdir(t1_dir);
@@ -91,7 +89,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	fullpath = alloca(rlen + name_len + 2);
 	if (!fullpath) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		return 1;
 	}
 
@@ -139,7 +137,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 		      "calling mount --bind " SLOPPY " -o %s %s %s",
 		      options, what, fullpath);
 
-		err = spawn_bind_mount(log_debug,
+		err = spawn_bind_mount(ap->logopt,
 			     SLOPPYOPT "-o", options, what, fullpath, NULL);
 
 		if (err) {
diff --git a/modules/mount_changer.c b/modules/mount_changer.c
index 6e04c7c..08d9147 100644
--- a/modules/mount_changer.c
+++ b/modules/mount_changer.c
@@ -66,7 +66,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	fullpath = alloca(rlen + name_len + 2);
 	if (!fullpath) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		return 1;
 	}
 
@@ -80,7 +80,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 
 	debug(ap->logopt, MODPREFIX "calling umount %s", what);
 
-	err = spawn_umount(log_debug, what, NULL);
+	err = spawn_umount(ap->logopt, what, NULL);
 	if (err) {
 		error(ap->logopt,
 		      MODPREFIX
@@ -115,18 +115,18 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 		      MODPREFIX "calling mount -t %s " SLOPPY "-o %s %s %s",
 		      fstype, options, what, fullpath);
 
-		err = spawn_mount(log_debug, "-t", fstype,
+		err = spawn_mount(ap->logopt, "-t", fstype,
 			     SLOPPYOPT "-o", options, what, fullpath, NULL);
 	} else {
 		debug(ap->logopt,
 		      MODPREFIX "calling mount -t %s %s %s",
 		      fstype, what, fullpath);
 
-		err = spawn_mount(log_debug, "-t", fstype, what, fullpath, NULL);
+		err = spawn_mount(ap->logopt, "-t", fstype, what, fullpath, NULL);
 	}
 
 	if (err) {
-		msg(MODPREFIX "failed to mount %s (type %s) on %s",
+		info(ap->logopt, MODPREFIX "failed to mount %s (type %s) on %s",
 		    what, fstype, fullpath);
 
 		if (ap->type != LKP_INDIRECT)
@@ -137,7 +137,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 
 		return 1;
 	} else {
-		msg(MODPREFIX "mounted %s type %s on %s",
+		info(ap->logopt, MODPREFIX "mounted %s type %s on %s",
 		    what, fstype, fullpath);
 		return 0;
 	}
@@ -161,7 +161,7 @@ int swapCD(const char *device, const char *slotName)
 	/* open device */
 	fd = open(device, O_RDONLY | O_NONBLOCK);
 	if (fd < 0) {
-		error(LOGOPT_ANY, MODPREFIX "Opening device %s failed : %s",
+		logerr(MODPREFIX "Opening device %s failed : %s",
 		      device, strerror(errno));
 		return 1;
 	}
@@ -174,7 +174,7 @@ int swapCD(const char *device, const char *slotName)
 	/* Check CD player status */
 	total_slots_available = ioctl(fd, CDROM_CHANGER_NSLOTS);
 	if (total_slots_available <= 1) {
-		error(LOGOPT_ANY, MODPREFIX
+		logerr(MODPREFIX
 		      "Device %s is not an ATAPI compliant CD changer.",
 		      device);
 		return 1;
@@ -183,14 +183,14 @@ int swapCD(const char *device, const char *slotName)
 	/* load */
 	slot = ioctl(fd, CDROM_SELECT_DISC, slot);
 	if (slot < 0) {
-		error(LOGOPT_ANY, MODPREFIX "CDROM_SELECT_DISC failed");
+		logerr(MODPREFIX "CDROM_SELECT_DISC failed");
 		return 1;
 	}
 
 	/* close device */
 	status = close(fd);
 	if (status != 0) {
-		error(LOGOPT_ANY, MODPREFIX "close failed for `%s': %s",
+		logerr(MODPREFIX "close failed for `%s': %s",
 		      device, strerror(errno));
 		return 1;
 	}
diff --git a/modules/mount_ext2.c b/modules/mount_ext2.c
index 45f0615..8cf9937 100644
--- a/modules/mount_ext2.c
+++ b/modules/mount_ext2.c
@@ -58,7 +58,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	fullpath = alloca(rlen + name_len + 2);
 	if (!fullpath) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		return 1;
 	}
 
@@ -108,11 +108,11 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	if (ro) {
 		debug(ap->logopt,
 		      MODPREFIX "calling %s -n %s", fsck_prog, what);
-		err = spawnl(log_debug, fsck_prog, fsck_prog, "-n", what, NULL);
+		err = spawnl(ap->logopt, fsck_prog, fsck_prog, "-n", what, NULL);
 	} else {
 		debug(ap->logopt,
 		      MODPREFIX "calling %s -p %s", fsck_prog, what);
-		err = spawnl(log_debug, fsck_prog, fsck_prog, "-p", what, NULL);
+		err = spawnl(ap->logopt, fsck_prog, fsck_prog, "-p", what, NULL);
 	}
 
 	/*
@@ -132,17 +132,17 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 		debug(ap->logopt,
 		      MODPREFIX "calling mount -t %s " SLOPPY "-o %s %s %s",
 		      fstype, options, what, fullpath);
-		err = spawn_mount(log_debug, "-t", fstype,
+		err = spawn_mount(ap->logopt, "-t", fstype,
 			     SLOPPYOPT "-o", options, what, fullpath, NULL);
 	} else {
 		debug(ap->logopt,
 		      MODPREFIX "calling mount -t %s %s %s",
 		      fstype, what, fullpath);
-		err = spawn_mount(log_debug, "-t", fstype, what, fullpath, NULL);
+		err = spawn_mount(ap->logopt, "-t", fstype, what, fullpath, NULL);
 	}
 
 	if (err) {
-		msg(MODPREFIX "failed to mount %s (type %s) on %s",
+		info(ap->logopt, MODPREFIX "failed to mount %s (type %s) on %s",
 		    what, fstype, fullpath);
 
 		if (ap->type != LKP_INDIRECT)
@@ -153,7 +153,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 
 		return 1;
 	} else {
-		debug(ap->logopt,
+		info(ap->logopt,
 		      MODPREFIX "mounted %s type %s on %s",
 		      what, fstype, fullpath);
 		return 0;
diff --git a/modules/mount_generic.c b/modules/mount_generic.c
index 1f43baa..85b4391 100644
--- a/modules/mount_generic.c
+++ b/modules/mount_generic.c
@@ -57,7 +57,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	fullpath = alloca(rlen + name_len + 2);
 	if (!fullpath) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		return 1;
 	}
 
@@ -93,16 +93,16 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 		      MODPREFIX "calling mount -t %s " SLOPPY "-o %s %s %s",
 		      fstype, options, what, fullpath);
 
-		err = spawn_mount(log_debug, "-t", fstype,
+		err = spawn_mount(ap->logopt, "-t", fstype,
 			     SLOPPYOPT "-o", options, what, fullpath, NULL);
 	} else {
 		debug(ap->logopt, MODPREFIX "calling mount -t %s %s %s",
 		      fstype, what, fullpath);
-		err = spawn_mount(log_debug, "-t", fstype, what, fullpath, NULL);
+		err = spawn_mount(ap->logopt, "-t", fstype, what, fullpath, NULL);
 	}
 
 	if (err) {
-		msg(MODPREFIX "failed to mount %s (type %s) on %s",
+		info(ap->logopt, MODPREFIX "failed to mount %s (type %s) on %s",
 		     what, fstype, fullpath);
 
 		if (ap->type != LKP_INDIRECT)
@@ -113,7 +113,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 
 		return 1;
 	} else {
-		msg(MODPREFIX "mounted %s type %s on %s",
+		info(ap->logopt, MODPREFIX "mounted %s type %s on %s",
 		    what, fstype, fullpath);
 		return 0;
 	}
diff --git a/modules/mount_nfs.c b/modules/mount_nfs.c
index e4480c5..bad21fc 100644
--- a/modules/mount_nfs.c
+++ b/modules/mount_nfs.c
@@ -133,14 +133,14 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	else
 		vers = NFS_VERS_MASK | NFS_PROTO_MASK;
 
-	if (!parse_location(&hosts, what)) {
-		warn(ap->logopt, MODPREFIX "no hosts available");
+	if (!parse_location(ap->logopt, &hosts, what)) {
+		info(ap->logopt, MODPREFIX "no hosts available");
 		return 1;
 	}
-	prune_host_list(&hosts, vers, nfsoptions, ap->random_selection);
+	prune_host_list(ap->logopt, &hosts, vers, nfsoptions, ap->random_selection);
 
 	if (!hosts) {
-		warn(ap->logopt, MODPREFIX "no hosts available");
+		info(ap->logopt, MODPREFIX "no hosts available");
 		return 1;
 	}
 
@@ -159,7 +159,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 	fullpath = alloca(rlen + name_len + 2);
 	if (!fullpath) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		free_host_list(&hosts);
 		return 1;
 	}
@@ -252,19 +252,19 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 			      MODPREFIX "calling mount -t %s " SLOPPY 
 			      "-o %s %s %s", fstype, nfsoptions, loc, fullpath);
 
-			err = spawn_mount(log_debug,
+			err = spawn_mount(ap->logopt,
 					  "-t", fstype, SLOPPYOPT "-o",
 					  nfsoptions, loc, fullpath, NULL);
 		} else {
 			debug(ap->logopt,
 			      MODPREFIX "calling mount -t %s %s %s",
 			      fstype, loc, fullpath);
-			err = spawn_mount(log_debug,
+			err = spawn_mount(ap->logopt,
 					  "-t", fstype, loc, fullpath, NULL);
 		}
 
 		if (!err) {
-			msg(MODPREFIX "mounted %s on %s", loc, fullpath);
+			info(ap->logopt, MODPREFIX "mounted %s on %s", loc, fullpath);
 			free(loc);
 			free_host_list(&hosts);
 			ap->ghost = save_ghost;
@@ -280,7 +280,7 @@ int mount_mount(struct autofs_point *ap, const char *root, const char *name, int
 
 	/* If we get here we've failed to complete the mount */
 
-	msg(MODPREFIX "nfs: mount failure %s on %s", what, fullpath);
+	info(ap->logopt, MODPREFIX "nfs: mount failure %s on %s", what, fullpath);
 
 	if (ap->type != LKP_INDIRECT)
 		return 1;
diff --git a/modules/parse_sun.c b/modules/parse_sun.c
index 079bda6..186e567 100644
--- a/modules/parse_sun.c
+++ b/modules/parse_sun.c
@@ -277,7 +277,7 @@ int parse_init(int argc, const char *const *argv, void **context)
 
 	if (!(ctxt = (struct parse_context *) malloc(sizeof(struct parse_context)))) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		crit(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		*context = NULL;
 		return 1;
 	}
@@ -302,7 +302,7 @@ int parse_init(int argc, const char *const *argv, void **context)
 
 				if (!def) {
 					char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-					error(LOGOPT_ANY, MODPREFIX "strdup: %s", estr);
+					logerr(MODPREFIX "strdup: %s", estr);
 					break;
 				}
 
@@ -387,7 +387,7 @@ int parse_init(int argc, const char *const *argv, void **context)
 			if (!noptstr) {
 				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 				kill_context(ctxt);
-				crit(LOGOPT_ANY, MODPREFIX "%s", estr);
+				logerr(MODPREFIX "%s", estr);
 				*context = NULL;
 				return 1;
 			}
@@ -408,7 +408,7 @@ int parse_init(int argc, const char *const *argv, void **context)
 			char *tmp = concat_options(gbl_options, ctxt->optstr);
 			if (!tmp) {
 				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				error(LOGOPT_ANY, MODPREFIX "concat_options: %s", estr);
+				logerr(MODPREFIX "concat_options: %s", estr);
 				free(gbl_options);
 			} else
 				ctxt->optstr = tmp;
@@ -472,7 +472,7 @@ static char *concat_options(char *left, char *right)
 
 	if (ret == NULL) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(LOGOPT_ANY, MODPREFIX "malloc: %s", estr);
+		logerr(MODPREFIX "malloc: %s", estr);
 		return NULL;
 	}
 
@@ -637,8 +637,7 @@ static int check_is_multi(const char *mapent)
 	int not_first_chunk = 0;
 
 	if (!p) {
-		crit(LOGOPT_ANY,
-		     MODPREFIX "unexpected NULL map entry pointer");
+		logerr(MODPREFIX "unexpected NULL map entry pointer");
 		return 0;
 	}
 
@@ -1021,7 +1020,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
 	pmapent = alloca(mapent_len + 1);
 	if (!pmapent) {	
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "alloca: %s", estr);
+		logerr(MODPREFIX "alloca: %s", estr);
 		ctxt->subst = removestdenv(ctxt->subst);
 		macro_unlock();
 		pthread_setcancelstate(cur_state, NULL);
@@ -1041,7 +1040,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
 	options = strdup(ctxt->optstr ? ctxt->optstr : "");
 	if (!options) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(ap->logopt, MODPREFIX "strdup: %s", estr);
+		logerr(MODPREFIX "strdup: %s", estr);
 		return 1;
 	}
 	optlen = strlen(options);
@@ -1119,7 +1118,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
 			if (!m_root) {
 				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 				free(options);
-				error(ap->logopt, MODPREFIX "alloca: %s", estr);
+				logerr(MODPREFIX "alloca: %s", estr);
 				return 1;
 			}
 			strcpy(m_root, name);
@@ -1129,7 +1128,7 @@ int parse_mount(struct autofs_point *ap, const char *name,
 			if (!m_root) {
 				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 				free(options);
-				error(ap->logopt, MODPREFIX "alloca: %s", estr);
+				logerr(MODPREFIX "alloca: %s", estr);
 				return 1;
 			}
 			strcpy(m_root, ap->path);
diff --git a/modules/replicated.c b/modules/replicated.c
index e15587c..14b20a9 100644
--- a/modules/replicated.c
+++ b/modules/replicated.c
@@ -113,7 +113,7 @@ static unsigned int get_proximity(const char *host_addr, int addr_len)
 	sock = socket(AF_INET, SOCK_DGRAM, 0);
 	if (sock < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(LOGOPT_ANY, "socket creation failed: %s", estr);
+		logerr("socket creation failed: %s", estr);
 		return PROXIMITY_ERROR;
 	}
 
@@ -127,7 +127,7 @@ static unsigned int get_proximity(const char *host_addr, int addr_len)
 	ret = ioctl(sock, SIOCGIFCONF, &ifc);
 	if (ret == -1) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-		error(LOGOPT_ANY, "ioctl: %s", estr);
+		logerr("ioctl: %s", estr);
 		close(sock);
 		return PROXIMITY_ERROR;
 	}
@@ -176,7 +176,7 @@ static unsigned int get_proximity(const char *host_addr, int addr_len)
 			ret = ioctl(sock, SIOCGIFNETMASK, &nmptr);
 			if (ret == -1) {
 				char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
-				error(LOGOPT_ANY, "ioctl: %s", estr);
+				logerr("ioctl: %s", estr);
 				close(sock);
 				return PROXIMITY_ERROR;
 			}
@@ -387,7 +387,7 @@ static unsigned short get_port_option(const char *options)
 	return (unsigned short) port;
 }
 
-static unsigned int get_nfs_info(struct host *host,
+static unsigned int get_nfs_info(unsigned logopt, struct host *host,
 			 struct conn_info *pm_info, struct conn_info *rpc_info,
 			 const char *proto, unsigned int version,
 			 const char *options, unsigned int random_selection)
@@ -533,7 +533,7 @@ done_ver:
 	return supported;
 }
 
-static int get_vers_and_cost(struct host *host,
+static int get_vers_and_cost(unsigned logopt, struct host *host,
 			     unsigned int version, const char *options,
 			     unsigned int random_selection)
 {
@@ -559,7 +559,7 @@ static int get_vers_and_cost(struct host *host,
 	vers &= version;
 
 	if (version & UDP_REQUESTED) {
-		supported = get_nfs_info(host,
+		supported = get_nfs_info(logopt, host,
 					&pm_info, &rpc_info, "udp", vers,
 					options, random_selection);
 		if (supported) {
@@ -569,7 +569,7 @@ static int get_vers_and_cost(struct host *host,
 	}
 
 	if (version & TCP_REQUESTED) {
-		supported = get_nfs_info(host,
+		supported = get_nfs_info(logopt, host,
 					 &pm_info, &rpc_info, "tcp", vers,
 					 options, random_selection);
 		if (supported) {
@@ -581,7 +581,7 @@ static int get_vers_and_cost(struct host *host,
 	return ret;
 }
 
-static int get_supported_ver_and_cost(struct host *host,
+static int get_supported_ver_and_cost(unsigned logopt, struct host *host,
 				      unsigned int version, const char *options,
 				      unsigned int random_selection)
 {
@@ -636,7 +636,7 @@ static int get_supported_ver_and_cost(struct host *host,
 		vers = NFS4_VERSION;
 		break;
 	default:
-		crit(LOGOPT_ANY, "called with invalid version: 0x%x\n", version);
+		crit(logopt, "called with invalid version: 0x%x\n", version);
 		return 0;
 	}
 
@@ -701,7 +701,7 @@ done:
 	return 0;
 }
 
-int prune_host_list(struct host **list,
+int prune_host_list(unsigned logopt, struct host **list,
 		    unsigned int vers, const char *options,
 		    unsigned int random_selection)
 {
@@ -742,7 +742,7 @@ int prune_host_list(struct host **list,
 			break;
 
 		if (this->name) {
-			status = get_vers_and_cost(this, vers,
+			status = get_vers_and_cost(logopt, this, vers,
 						   options, random_selection);
 			if (!status) {
 				if (this == first) {
@@ -833,7 +833,7 @@ int prune_host_list(struct host **list,
 			remove_host(list, this);
 			add_host(&new, this);
 		} else {
-			status = get_supported_ver_and_cost(this,
+			status = get_supported_ver_and_cost(logopt, this,
 						selected_version, options,
 						random_selection);
 			if (status) {
@@ -886,11 +886,9 @@ static int add_host_addrs(struct host **list, const char *host, unsigned int wei
 			buf, MAX_IFC_BUF, &result, &ghn_errno);
 	if (ret || !result) {
 		if (ghn_errno == -1)
-			error(LOGOPT_ANY,
-			      "host %s: lookup failure %d", host, errno);
+			logmsg("host %s: lookup failure %d", host, errno);
 		else
-			error(LOGOPT_ANY,
-			      "host %s: lookup failure %d", host, ghn_errno);
+			logmsg("host %s: lookup failure %d", host, ghn_errno);
 		return 0;
 	}
 
@@ -965,7 +963,7 @@ static int add_local_path(struct host **hosts, const char *path)
 	return 1;
 }
 
-int parse_location(struct host **hosts, const char *list)
+int parse_location(unsigned logopt, struct host **hosts, const char *list)
 {
 	char *str, *p, *delim;
 	unsigned int empty = 1;
@@ -1072,8 +1070,7 @@ void dump_host_list(struct host *hosts)
 
 	this = hosts;
 	while (this) {
-		debug(LOGOPT_ANY,
-		      "name %s path %s version %x proximity %u weight %u cost %u",
+		logmsg("name %s path %s version %x proximity %u weight %u cost %u",
 		      this->name, this->path, this->version,
 		      this->proximity, this->weight, this->cost);
 		this = this->next;
