autofs-5.0.4 - library reload fix update fix

From: Ian Kent <raven@themaw.net>

The library reload fixes introduced a bug which causes autofs to
incorrectly shutdown. Previously the signal handling thread only
recieved signals either when they were explicity sent or it was
time to shutdown so continuing on to call the signal handling
routine was the correct thing to do. Now we need to join with
the mount handling thread at exit but, in this case, we don't
want to continue on to the signal handling routine as that will
incorrectly cause the signal to be passed on to other mount
handling threads.
---

 CHANGELOG          |    1 +
 daemon/automount.c |   18 ++++++++++++++++--
 lib/master.c       |    2 --
 3 files changed, 17 insertions(+), 4 deletions(-)


diff --git a/CHANGELOG b/CHANGELOG
index 7ca45fd..5e01812 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -44,6 +44,7 @@
 - use intr option as hosts mount default.
 - fix kernel includes.
 - dont umount existing direct mount on master re-read.
+- fix incorrect shutdown introduced by library relaod fixes.
 
 4/11/2008 autofs-5.0.4
 -----------------------
diff --git a/daemon/automount.c b/daemon/automount.c
index 80691fa..3a0fe0b 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -1332,8 +1332,22 @@ static void *statemachine(void *arg)
 		case SIGTERM:
 		case SIGINT:
 		case SIGUSR2:
-			if (master_done(master_list))
-				return NULL;
+			master_mutex_lock();
+			if (list_empty(&master_list->completed)) {
+				if (list_empty(&master_list->mounts)) {
+					master_mutex_unlock();
+					return NULL;
+				}
+			} else {
+				if (master_done(master_list)) {
+					master_mutex_unlock();
+					return NULL;
+				}
+				master_mutex_unlock();
+				break;
+			}
+			master_mutex_unlock();
+
 		case SIGUSR1:
 			do_signals(master_list, sig);
 			break;
diff --git a/lib/master.c b/lib/master.c
index 762094f..e43f835 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -1182,7 +1182,6 @@ int master_done(struct master *master)
 	struct master_mapent *entry;
 	int res = 0;
 
-	master_mutex_lock();
 	head = &master->completed;
 	p = head->next;
 	while (p != head) {
@@ -1195,7 +1194,6 @@ int master_done(struct master *master)
 	}
 	if (list_empty(&master->mounts))
 		res = 1;
-	master_mutex_unlock();
 
 	return res;
 }
