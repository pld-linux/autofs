diff --git a/CHANGELOG b/CHANGELOG
index 74d39fd..2c815e7 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -42,6 +42,7 @@
 - handle MTAB_NOTUPDATED status return from mount.
 - when default master map, auto.master, is used also check for auto_master.
 - fix schema selection in LDAP schema discovery.
+- update negative mount timeout handling.
 
 18/06/2007 autofs-5.0.2
 -----------------------
diff --git a/daemon/automount.c b/daemon/automount.c
index a12b6da..7becad5 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -58,6 +58,8 @@ const char *global_options;		/* Global option, from command line */
 static char *pid_file = NULL;		/* File in which to keep pid */
 unsigned int global_random_selection;	/* use random policy when selecting
 					 * which multi-mount host to mount */
+long global_negative_timeout = -1;
+
 static int start_pipefd[2];
 static int st_stat = 0;
 static int *pst_stat = &st_stat;
@@ -1671,6 +1673,8 @@ static void usage(void)
 		"	-f --foreground do not fork into background\n"
 		"	-r --random-multimount-selection\n"
 		"			use ramdom replicated server selection\n"
+		"	-n --negative-timeout n\n"
+		"			set the timeout for failed key lookups.\n"
 		"	-O --global-options\n"
 		"			specify global mount options\n"
 		"	-l --set-log-priority priority path [path,...]\n"
@@ -1810,6 +1814,7 @@ int main(int argc, char *argv[])
 		{"define", 1, 0, 'D'},
 		{"foreground", 0, 0, 'f'},
 		{"random-multimount-selection", 0, 0, 'r'},
+		{"negative-timeout", 1, 0, 'n'},
 		{"global-options", 1, 0, 'O'},
 		{"version", 0, 0, 'V'},
 		{"set-log-priority", 1, 0, 'l'},
@@ -1833,7 +1838,7 @@ int main(int argc, char *argv[])
 	foreground = 0;
 
 	opterr = 0;
-	while ((opt = getopt_long(argc, argv, "+hp:t:vdD:fVrO:l:", long_options, NULL)) != EOF) {
+	while ((opt = getopt_long(argc, argv, "+hp:t:vdD:fVrO:l:n:", long_options, NULL)) != EOF) {
 		switch (opt) {
 		case 'h':
 			usage();
@@ -1871,6 +1876,10 @@ int main(int argc, char *argv[])
 			global_random_selection = 1;
 			break;
 
+		case 'n':
+			global_negative_timeout = getnumopt(optarg, opt);
+			break;
+
 		case 'O':
 			if (!have_global_options) {
 				global_options = strdup(optarg);
diff --git a/include/automount.h b/include/automount.h
index b0d1a9c..4887da6 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -442,6 +442,7 @@ struct autofs_point {
 	unsigned int type;		/* Type of map direct or indirect */
 	time_t exp_timeout;		/* Timeout for expiring mounts */
 	time_t exp_runfreq;		/* Frequency for polling for timeouts */
+	time_t negative_timeout;	/* timeout in secs for failed mounts */
 	unsigned ghost;			/* Enable/disable gohsted directories */
 	unsigned logopt;		/* Per map logging */
 	pthread_t exp_thread;		/* Thread that is expiring */
diff --git a/include/defaults.h b/include/defaults.h
index e296478..6e4f52a 100644
--- a/include/defaults.h
+++ b/include/defaults.h
@@ -22,9 +22,10 @@
 
 #define DEFAULT_MASTER_MAP_NAME	"auto.master"
 
-#define DEFAULT_TIMEOUT		600
-#define DEFAULT_BROWSE_MODE	1
-#define DEFAULT_LOGGING		0
+#define DEFAULT_TIMEOUT			600
+#define DEFAULT_NEGATIVE_TIMEOUT	60
+#define DEFAULT_BROWSE_MODE		1
+#define DEFAULT_LOGGING			0
 
 #define DEFAULT_LDAP_TIMEOUT		-1
 #define DEFAULT_LDAP_NETWORK_TIMEOUT	8
@@ -45,6 +46,7 @@ unsigned int defaults_read_config(unsigned int);
 const char *defaults_get_master_map(void);
 int defaults_master_set(void);
 unsigned int defaults_get_timeout(void);
+unsigned int defaults_get_negative_timeout(void);
 unsigned int defaults_get_browse_mode(void);
 unsigned int defaults_get_logging(void);
 const char *defaults_get_ldap_server(void);
diff --git a/lib/defaults.c b/lib/defaults.c
index f494103..8149549 100644
--- a/lib/defaults.c
+++ b/lib/defaults.c
@@ -28,6 +28,7 @@
 #define ENV_NAME_MASTER_MAP		"MASTER_MAP_NAME"
 
 #define ENV_NAME_TIMEOUT		"TIMEOUT"
+#define ENV_NAME_NEGATIVE_TIMEOUT	"NEGATIVE_TIMEOUT"
 #define ENV_NAME_BROWSE_MODE		"BROWSE_MODE"
 #define ENV_NAME_LOGGING		"LOGGING"
 
@@ -308,6 +309,7 @@ unsigned int defaults_read_config(unsigned int to_syslog)
 
 		if (check_set_config_value(key, ENV_NAME_MASTER_MAP, value, to_syslog) ||
 		    check_set_config_value(key, ENV_NAME_TIMEOUT, value, to_syslog) ||
+		    check_set_config_value(key, ENV_NAME_NEGATIVE_TIMEOUT, value, to_syslog) ||
 		    check_set_config_value(key, ENV_NAME_BROWSE_MODE, value, to_syslog) ||
 		    check_set_config_value(key, ENV_NAME_LOGGING, value, to_syslog) ||
 		    check_set_config_value(key, ENV_LDAP_TIMEOUT, value, to_syslog) ||
@@ -370,6 +372,17 @@ unsigned int defaults_get_timeout(void)
 	return (unsigned int) timeout;
 }
 
+unsigned int defaults_get_negative_timeout(void)
+{
+	long n_timeout;
+
+	n_timeout = get_env_number(ENV_NAME_NEGATIVE_TIMEOUT);
+	if (n_timeout <= 0)
+		n_timeout = DEFAULT_NEGATIVE_TIMEOUT;
+
+	return (unsigned int) n_timeout;
+}
+
 unsigned int defaults_get_browse_mode(void)
 {
 	int res;
diff --git a/lib/master.c b/lib/master.c
index 2188bca..c001d20 100644
--- a/lib/master.c
+++ b/lib/master.c
@@ -30,6 +30,8 @@
 /* The root of the map entry tree */
 struct master *master_list = NULL;
 
+extern long global_negative_timeout;
+
 /* Attribute to create detached thread */
 extern pthread_attr_t thread_attr;
 
@@ -68,6 +70,14 @@ int master_add_autofs_point(struct master_mapent *entry,
 	ap->exp_thread = 0;
 	ap->readmap_thread = 0;
 	ap->exp_timeout = timeout;
+	/*
+	 * Program command line option overrides config.
+	 * We can't use 0 negative timeout so use default.
+	 */
+	if (global_negative_timeout <= 0)
+		ap->negative_timeout = defaults_get_negative_timeout();
+	else
+		ap->negative_timeout = global_negative_timeout;
 	ap->exp_runfreq = (timeout + CHECK_RATIO - 1) / CHECK_RATIO;
 	ap->ghost = ghost;
 
diff --git a/lib/master_parse.y b/lib/master_parse.y
index a767f9e..b450122 100644
--- a/lib/master_parse.y
+++ b/lib/master_parse.y
@@ -55,6 +55,7 @@ static char *path;
 static char *type;
 static char *format;
 static long timeout;
+static long negative_timeout;
 static unsigned ghost;
 extern unsigned global_random_selection;
 static unsigned random_selection;
@@ -95,7 +96,8 @@ static int master_fprintf(FILE *, char *, ...);
 
 %token COMMENT
 %token MAP
-%token OPT_TIMEOUT OPT_NOGHOST OPT_GHOST OPT_VERBOSE OPT_DEBUG OPT_RANDOM
+%token OPT_TIMEOUT OPT_NTIMEOUT OPT_NOGHOST OPT_GHOST OPT_VERBOSE
+%token OPT_DEBUG OPT_RANDOM
 %token COLON COMMA NL DDASH
 %type <strtype> map
 %type <strtype> options
@@ -542,6 +544,7 @@ option: daemon_option
 	;
 
 daemon_option: OPT_TIMEOUT NUMBER { timeout = $2; }
+	| OPT_NTIMEOUT NUMBER { negative_timeout = $2; }
 	| OPT_NOGHOST	{ ghost = 0; }
 	| OPT_GHOST	{ ghost = 1; }
 	| OPT_VERBOSE	{ verbose = 1; }
@@ -603,6 +606,7 @@ static void local_init_vars(void)
 	verbose = 0;
 	debug = 0;
 	timeout = -1;
+	negative_timeout = 0;
 	ghost = defaults_get_browse_mode();
 	random_selection = global_random_selection;
 	tmp_argv = NULL;
@@ -793,6 +797,8 @@ int master_parse_entry(const char *buffer, unsigned int default_timeout, unsigne
 		}
 	}
 	entry->ap->random_selection = random_selection;
+	if (negative_timeout)
+		entry->ap->negative_timeout = negative_timeout;
 
 /*
 	source = master_find_map_source(entry, type, format,
diff --git a/lib/master_tok.l b/lib/master_tok.l
index 36aa785..d908047 100644
--- a/lib/master_tok.l
+++ b/lib/master_tok.l
@@ -118,6 +118,7 @@ MTYPE		((file|program|yp|nis|nisplus|ldap|ldaps|hesiod|userdir)(,(sun|hesiod))?(
 
 
 OPTTOUT		(-t{OPTWS}|-t{OPTWS}={OPTWS}|--timeout{OPTWS}|--timeout{OPTWS}={OPTWS})
+OPTNTOUT	(-n{OPTWS}|-n{OPTWS}={OPTWS}|--negative-timeout{OPTWS}|--negative-timeout{OPTWS}={OPTWS})
 
 %%
 
@@ -321,6 +322,8 @@ OPTTOUT		(-t{OPTWS}|-t{OPTWS}={OPTWS}|--timeout{OPTWS}|--timeout{OPTWS}={OPTWS})
 
 	{OPTTOUT}/{NUMBER} { return(OPT_TIMEOUT); }
 
+	{OPTNTOUT}/{NUMBER} { return(OPT_NTIMEOUT); }
+
 	{NUMBER} {
 		master_lval.longtype = atol(master_text);
 		return(NUMBER);
diff --git a/man/auto.master.5.in b/man/auto.master.5.in
index 68447e0..d488960 100644
--- a/man/auto.master.5.in
+++ b/man/auto.master.5.in
@@ -152,6 +152,11 @@ Enables the use of ramdom selection when choosing a host from a
 list of replicated servers. This option is applied to this mount
 only, overriding the global setting that may be specified on the
 command line.
+.TP
+.I "\-n, \-\-negative\-timeout <seconds>"
+Set the timeout for caching failed key lookups. This option can be
+used to override the global default given either on the command line
+or in the configuration.
 .SH GENERAL SYSTEM DEFAULTS CONFIGURATION
 .P
 The default value of several general settings may be changed in the
@@ -164,6 +169,11 @@ They are:
 .B TIMEOUT
 sets the default mount timeout (program default 600).
 .TP
+.B NEGATIVE_TIMEOUT
+Set the default timeout for caching failed key lookups (program default
+60). If the equivalent command line option is given it will override this
+setting.
+.TP
 .B BROWSE_MODE
 Maps are browsable by default (program default "yes").
 .TP
diff --git a/man/automount.8 b/man/automount.8
index 5cd63c7..59ad50e 100644
--- a/man/automount.8
+++ b/man/automount.8
@@ -34,6 +34,9 @@ Set the global minimum timeout, in seconds, until directories
 are unmounted. The default is 10 minutes. Setting the timeout
 to zero disables umounts completely.
 .TP
+.I "\-n <seconds>, \-\-negative\-timeout <seconds>"
+Set the default timeout for caching failed key lookups. The default is 60 seconds.
+.TP
 .I "\-v, \-\-verbose"
 Enables logging of general status and progress messages for all
 autofs managed mounts.
diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index c093415..1007de4 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -1126,7 +1126,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				rv = cache_update(mc, source, key, NULL, now);
 			if (rv != CHE_FAIL) {
 				me = cache_lookup_distinct(mc, key);
-				me->status = now + NEGATIVE_TIMEOUT;
+				me->status = now + ap->negative_timeout;
 			}
 			cache_unlock(mc);
 		}
diff --git a/modules/lookup_hosts.c b/modules/lookup_hosts.c
index d746e42..1ef420e 100644
--- a/modules/lookup_hosts.c
+++ b/modules/lookup_hosts.c
@@ -138,7 +138,10 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 
 	cache_readlock(mc);
 	me = cache_lookup_distinct(mc, name);
-	if (!me) {
+	if (me && me->status >= time(NULL)) {
+		cache_unlock(mc);
+		return NSS_STATUS_NOTFOUND;
+	} else if (!me) {
 		cache_unlock(mc);
 		/*
 		 * We haven't read the list of hosts into the
@@ -192,10 +195,22 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		ret = ctxt->parse->parse_mount(ap, name, name_len,
 				 mapent, ctxt->parse->context);
 
-		if (!ret)
-			return NSS_STATUS_SUCCESS;
-
-		return NSS_STATUS_TRYAGAIN;
+		if (ret) {
+			time_t now = time(NULL);
+			int rv = CHE_OK;
+
+			cache_writelock(mc);
+			me = cache_lookup_distinct(mc, name);
+			if (!me)
+				rv = cache_update(mc, source, name, NULL, now);
+			if (rv != CHE_FAIL) {
+				me = cache_lookup_distinct(mc, name);
+				me->status = now + ap->negative_timeout;
+			}
+			cache_unlock(mc);
+			return NSS_STATUS_TRYAGAIN;
+		}
+		return NSS_STATUS_SUCCESS;
 	}
 done:
 	/*
@@ -267,8 +282,21 @@ done:
 				 mapent, ctxt->parse->context);
 	free(mapent);
 
-	if (ret)
+	if (ret) {
+		time_t now = time(NULL);
+		int rv = CHE_OK;
+
+		cache_writelock(mc);
+		me = cache_lookup_distinct(mc, name);
+		if (!me)
+			rv = cache_update(mc, source, name, NULL, now);
+		if (rv != CHE_FAIL) {
+			me = cache_lookup_distinct(mc, name);
+			me->status = now + ap->negative_timeout;
+		}
+		cache_unlock(mc);
 		return NSS_STATUS_TRYAGAIN;
+	}
 
 	return NSS_STATUS_SUCCESS;
 }
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index 8719af9..4dea3b2 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -2125,7 +2125,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				rv = cache_update(mc, source, key, NULL, now);
 			if (rv != CHE_FAIL) {
 				me = cache_lookup_distinct(mc, key);
-				me->status = now + NEGATIVE_TIMEOUT;
+				me->status = now + ap->negative_timeout;
 			}
 			cache_unlock(mc);
 		}
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index bcdaeeb..e948c14 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -547,7 +547,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				rv = cache_update(mc, source, key, NULL, now);
 			if (rv != CHE_FAIL) {
 				me = cache_lookup_distinct(mc, key);
-				me->status = time(NULL) + NEGATIVE_TIMEOUT;
+				me->status = time(NULL) + ap->negative_timeout;
 			}
 			cache_unlock(mc);
 		}
diff --git a/modules/lookup_program.c b/modules/lookup_program.c
index e28168e..7c266d6 100644
--- a/modules/lookup_program.c
+++ b/modules/lookup_program.c
@@ -134,7 +134,10 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	/* Catch installed direct offset triggers */
 	cache_readlock(mc);
 	me = cache_lookup_distinct(mc, name);
-	if (!me) {
+	if (me && me->status >= time(NULL)) {
+		cache_unlock(mc);
+		return NSS_STATUS_NOTFOUND;
+	} else if (!me) {
 		cache_unlock(mc);
 		/*
 		 * If there's a '/' in the name and the offset is not in
@@ -147,15 +150,33 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 		}
 	} else {
 		cache_unlock(mc);
+
 		/* Otherwise we found a valid offset so try mount it */
 		debug(ap->logopt, MODPREFIX "%s -> %s", name, me->mapent);
 
-		master_source_current_wait(ap->entry);
-		ap->entry->current = source;
-
-		ret = ctxt->parse->parse_mount(ap, name, name_len,
-				      me->mapent, ctxt->parse->context);
-		goto out_free;
+		/*
+		 * If this is a request for an offset mount (whose entry
+		 * must be present in the cache to be valid) or the entry
+		 * is newer than the negative timeout value then just
+		 * try and mount it. Otherwise try and remove it and
+		 * proceed with the program map lookup.
+		 */
+		if (strchr(name, '/') ||
+		    me->age + ap->negative_timeout > time(NULL)) {
+			master_source_current_wait(ap->entry);
+			ap->entry->current = source;
+			ret = ctxt->parse->parse_mount(ap, name,
+				 name_len, me->mapent, ctxt->parse->context);
+			goto out_free;
+		} else {
+			if (me->multi) {
+				warn(ap->logopt, MODPREFIX
+				     "unexpected lookup for active multi-mount"
+				     " key %s, returning fail", name);
+				return NSS_STATUS_UNAVAIL;
+			}
+			cache_delete(mc, name);
+		}
 	}
 
 	mapent = (char *) malloc(MAPENT_MAX_LEN + 1);
@@ -356,8 +377,21 @@ out_free:
 	if (mapent)
 		free(mapent);
 
-	if (ret)
+	if (ret) {
+		time_t now = time(NULL);
+		int rv = CHE_OK;
+
+		cache_writelock(mc);
+		me = cache_lookup_distinct(mc, name);
+		if (!me)
+			rv = cache_update(mc, source, name, NULL, now);
+		if (rv != CHE_FAIL) {
+			me = cache_lookup_distinct(mc, name);
+			me->status = now + ap->negative_timeout;
+		}
+		cache_unlock(mc);
 		return NSS_STATUS_UNAVAIL;
+	}
 
 	return NSS_STATUS_SUCCESS;
 }
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index 7ba6940..6c20145 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -639,7 +639,7 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 				rv = cache_update(mc, source, key, NULL, now);
 			if (rv != CHE_FAIL) {
 				me = cache_lookup_distinct(mc, key);
-				me->status = now + NEGATIVE_TIMEOUT;
+				me->status = now + ap->negative_timeout;
 			}
 			cache_unlock(mc);
 		}
diff --git a/redhat/autofs.sysconfig.in b/redhat/autofs.sysconfig.in
index f01ee5f..636763a 100644
--- a/redhat/autofs.sysconfig.in
+++ b/redhat/autofs.sysconfig.in
@@ -9,6 +9,11 @@
 #
 TIMEOUT=300
 #
+# NEGATIVE_TIMEOUT - set the default negative timeout for
+# 		     failed mount attempts (default 60).
+#
+#NEGATIVE_TIMEOUT=60
+#
 # BROWSE_MODE - maps are browsable by default.
 #
 BROWSE_MODE="no"
diff --git a/samples/autofs.conf.default.in b/samples/autofs.conf.default.in
index 028341c..086ba4f 100644
--- a/samples/autofs.conf.default.in
+++ b/samples/autofs.conf.default.in
@@ -9,6 +9,11 @@
 #
 TIMEOUT=300
 #
+# NEGATIVE_TIMEOUT - set the default negative timeout for
+# 		     failed mount attempts (default 60).
+#
+#NEGATIVE_TIMEOUT=60
+#
 # BROWSE_MODE - maps are browsable by default.
 #
 BROWSE_MODE="no"
