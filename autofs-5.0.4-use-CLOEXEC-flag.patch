autofs-5.0.4 - use CLOEXEC flag

From: Ian Kent <raven@themaw.net>

Update autofs to use the new CLOEXEC flag if present.
This allows us to set close on exec atomically flag when opening files,
hopefully avoiding selinux complaining about leaked file handles.
---

 CHANGELOG                 |    1 
 daemon/automount.c        |   42 ++++--------------
 daemon/direct.c           |    2 -
 daemon/flag.c             |    8 ++-
 daemon/indirect.c         |    2 -
 daemon/lookup.c           |    1 
 daemon/module.c           |    2 -
 daemon/spawn.c            |   11 +----
 include/automount.h       |  106 +++++++++++++++++++++++++++++++++++++++++++++
 include/state.h           |    1 
 lib/cache.c               |    2 -
 lib/defaults.c            |    7 ++-
 lib/dev-ioctl-lib.c       |   17 +------
 lib/log.c                 |    2 -
 lib/macros.c              |    1 
 lib/mounts.c              |    2 -
 lib/nss_parse.y           |   13 +-----
 lib/parse_subs.c          |    1 
 lib/rpc_subs.c            |   21 ++-------
 modules/cyrus-sasl.c      |    1 
 modules/lookup_file.c     |   40 +++--------------
 modules/lookup_hesiod.c   |    1 
 modules/lookup_hosts.c    |    1 
 modules/lookup_ldap.c     |    1 
 modules/lookup_multi.c    |    1 
 modules/lookup_nisplus.c  |    1 
 modules/lookup_program.c  |    5 +-
 modules/lookup_userhome.c |    1 
 modules/lookup_yp.c       |    1 
 modules/mount_afs.c       |    2 -
 modules/mount_autofs.c    |    2 -
 modules/mount_bind.c      |    2 -
 modules/mount_changer.c   |   10 ----
 modules/mount_ext2.c      |    2 -
 modules/mount_generic.c   |    2 -
 modules/mount_nfs.c       |    2 -
 modules/parse_hesiod.c    |    1 
 modules/parse_sun.c       |    2 -
 modules/replicated.c      |   13 +-----
 39 files changed, 149 insertions(+), 184 deletions(-)


diff --git a/CHANGELOG b/CHANGELOG
index bd35b00..43f3205 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -3,6 +3,7 @@
 - fix dumb libxml2 check
 - fix nested submount expire deadlock.
 - fix negative caching for non-existent map keys.
+- use CLOEXEC flag.
 
 4/11/2008 autofs-5.0.4
 -----------------------
diff --git a/daemon/automount.c b/daemon/automount.c
index 6f078c1..e120f50 100644
--- a/daemon/automount.c
+++ b/daemon/automount.c
@@ -20,13 +20,11 @@
  * ----------------------------------------------------------------------- */
 
 #include <dirent.h>
-#include <fcntl.h>
 #include <getopt.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <sys/ioctl.h>
 #include <ctype.h>
 #include <sys/types.h>
@@ -68,6 +66,9 @@ static pthread_t state_mach_thid;
 /* Pre-calculated kernel packet length */
 static size_t kpkt_len;
 
+/* Does kernel know about SOCK_CLOEXEC and friends */
+static int cloexec_works = 0;
+
 /* Attribute to create detached thread */
 pthread_attr_t thread_attr;
 
@@ -671,7 +672,7 @@ static char *automount_path_to_fifo(unsigned logopt, const char *path)
 static int create_logpri_fifo(struct autofs_point *ap)
 {
 	int ret = -1;
-	int fd, cl_flags;
+	int fd;
 	char *fifo_name;
 	char buf[MAX_ERR_BUF];
 
@@ -697,7 +698,7 @@ static int create_logpri_fifo(struct autofs_point *ap)
 		goto out_free;
 	}
 
-	fd = open(fifo_name, O_RDWR|O_NONBLOCK);
+	fd = open_fd(fifo_name, O_RDWR|O_NONBLOCK);
 	if (fd < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 		crit(ap->logopt,
@@ -707,11 +708,6 @@ static int create_logpri_fifo(struct autofs_point *ap)
 		goto out_free;
 	}
 
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	ap->logpri_fifo = fd;
 
 out_free:
@@ -963,7 +959,7 @@ int do_expire(struct autofs_point *ap, const char *name, int namelen)
 
 static int autofs_init_ap(struct autofs_point *ap)
 {
-	int pipefd[2], cl_flags;
+	int pipefd[2];
 
 	if ((ap->state != ST_INIT)) {
 		/* This can happen if an autofs process is already running*/
@@ -974,7 +970,7 @@ static int autofs_init_ap(struct autofs_point *ap)
 	ap->pipefd = ap->kpipefd = ap->ioctlfd = -1;
 
 	/* Pipe for kernel communications */
-	if (pipe(pipefd) < 0) {
+	if (open_pipe(pipefd) < 0) {
 		crit(ap->logopt,
 		     "failed to create commumication pipe for autofs path %s",
 		     ap->path);
@@ -984,18 +980,8 @@ static int autofs_init_ap(struct autofs_point *ap)
 	ap->pipefd = pipefd[0];
 	ap->kpipefd = pipefd[1];
 
-	if ((cl_flags = fcntl(ap->pipefd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->pipefd, F_SETFD, cl_flags);
-	}
-
-	if ((cl_flags = fcntl(ap->kpipefd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->kpipefd, F_SETFD, cl_flags);
-	}
-
 	/* Pipe state changes from signal handler to main loop */
-	if (pipe(ap->state_pipe) < 0) {
+	if (open_pipe(ap->state_pipe) < 0) {
 		crit(ap->logopt,
 		     "failed create state pipe for autofs path %s", ap->path);
 		close(ap->pipefd);
@@ -1003,16 +989,6 @@ static int autofs_init_ap(struct autofs_point *ap)
 		return -1;
 	}
 
-	if ((cl_flags = fcntl(ap->state_pipe[0], F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->state_pipe[0], F_SETFD, cl_flags);
-	}
-
-	if ((cl_flags = fcntl(ap->state_pipe[1], F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(ap->state_pipe[1], F_SETFD, cl_flags);
-	}
-
 	if (create_logpri_fifo(ap) < 0) {
 		logmsg("could not create FIFO for path %s\n", ap->path);
 		logmsg("dynamic log level changes not available for %s", ap->path);
@@ -1080,7 +1056,7 @@ static void become_daemon(unsigned foreground, unsigned daemon_check)
 		exit(0);
 	}
 
-	if (pipe(start_pipefd) < 0) {
+	if (open_pipe(start_pipefd) < 0) {
 		fprintf(stderr, "%s: failed to create start_pipefd.\n",
 			program);
 		exit(0);
diff --git a/daemon/direct.c b/daemon/direct.c
index 98fcc07..c0243c4 100644
--- a/daemon/direct.c
+++ b/daemon/direct.c
@@ -21,12 +21,10 @@
 
 #include <dirent.h>
 #include <libgen.h>
-#include <fcntl.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/wait.h>
diff --git a/daemon/flag.c b/daemon/flag.c
index d8ca61b..e43cece 100644
--- a/daemon/flag.c
+++ b/daemon/flag.c
@@ -21,15 +21,15 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <fcntl.h>
 #include <time.h>
-#include <unistd.h>
 #include <string.h>
 #include <alloca.h>
 #include <stdio.h>
 #include <signal.h>
 #include <errno.h>
 
+#include "automount.h"
+
 #define MAX_PIDSIZE	20
 #define FLAG_FILE	AUTOFS_FLAG_DIR "/autofs-running"
 
@@ -129,7 +129,7 @@ int aquire_flag_file(void)
 	while (!we_created_flagfile) {
 		int errsv, i, j;
 
-		i = open(linkf, O_WRONLY|O_CREAT, 0);
+		i = open_fd_mode(linkf, O_WRONLY|O_CREAT, 0);
 		if (i < 0) {
 			release_flag_file();
 			return 0;
@@ -146,7 +146,7 @@ int aquire_flag_file(void)
 			return 0;
 		}
 
-		fd = open(FLAG_FILE, O_RDWR);
+		fd = open_fd(FLAG_FILE, O_RDWR);
 		if (fd < 0) {
 			/* Maybe the file was just deleted? */
 			if (errno == ENOENT)
diff --git a/daemon/indirect.c b/daemon/indirect.c
index 1232810..9d3745c 100644
--- a/daemon/indirect.c
+++ b/daemon/indirect.c
@@ -21,12 +21,10 @@
 
 #include <dirent.h>
 #include <libgen.h>
-#include <fcntl.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/wait.h>
diff --git a/daemon/lookup.c b/daemon/lookup.c
index 0cf6e3f..741d846 100644
--- a/daemon/lookup.c
+++ b/daemon/lookup.c
@@ -22,7 +22,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <sys/stat.h>
-#include <unistd.h>
 #include "automount.h"
 #include "nsswitch.h"
 
diff --git a/daemon/module.c b/daemon/module.c
index 36eca00..e593d75 100644
--- a/daemon/module.c
+++ b/daemon/module.c
@@ -31,7 +31,7 @@ int load_autofs4_module(void)
 	 * is an older version we will catch it at mount
 	 * time.
 	 */
-	fp = fopen("/proc/filesystems", "r");
+	fp = open_fopen_r("/proc/filesystems");
 	if (!fp) {
 		logerr("cannot open /proc/filesystems\n");
 		return 0;
diff --git a/daemon/spawn.c b/daemon/spawn.c
index 17f92f4..4ddf46f 100644
--- a/daemon/spawn.c
+++ b/daemon/spawn.c
@@ -13,7 +13,6 @@
  *
  * ----------------------------------------------------------------------- */
 
-#include <fcntl.h>
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -21,7 +20,6 @@
 #include <string.h>
 #include <sys/types.h>
 #include <dirent.h>
-#include <unistd.h>
 #include <time.h>
 #include <sys/wait.h>
 #include <sys/stat.h>
@@ -125,7 +123,7 @@ static int do_spawn(unsigned logopt, unsigned int wait,
 	int ret, status, pipefd[2];
 	char errbuf[ERRBUFSIZ + 1], *p, *sp;
 	int errp, errn;
-	int flags, cancel_state;
+	int cancel_state;
 	unsigned int use_lock = options & SPAWN_OPT_LOCK;
 	unsigned int use_access = options & SPAWN_OPT_ACCESS;
 	sigset_t allsigs, tmpsig, oldsig;
@@ -133,7 +131,7 @@ static int do_spawn(unsigned logopt, unsigned int wait,
 	pid_t euid = 0;
 	gid_t egid = 0;
 
-	if (pipe(pipefd))
+	if (open_pipe(pipefd))
 		return -1;
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cancel_state);
@@ -213,11 +211,6 @@ static int do_spawn(unsigned logopt, unsigned int wait,
 			return -1;
 		}
 
-		if ((flags = fcntl(pipefd[0], F_GETFD, 0)) != -1) {
-			flags |= FD_CLOEXEC;
-			fcntl(pipefd[0], F_SETFD, flags);
-		}
-
 		errp = 0;
 		do {
 			errn = timed_read(pipefd[0],
diff --git a/include/automount.h b/include/automount.h
index 1ba0d3c..a55ddbc 100644
--- a/include/automount.h
+++ b/include/automount.h
@@ -17,6 +17,8 @@
 #include <pthread.h>
 #include <sched.h>
 #include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
 #include "config.h"
 #include "list.h"
 
@@ -475,5 +477,109 @@ int alarm_start_handler(void);
 int alarm_add(struct autofs_point *ap, time_t seconds);
 void alarm_delete(struct autofs_point *ap);
 
+/*
+ * Use CLOEXEC flag for open(), pipe(), fopen() (read-only case) and
+ * socket() if possible.
+ */
+static int cloexec_works;
+
+static inline void check_cloexec(int fd)
+{
+	if (cloexec_works == 0) {
+		int fl = fcntl(fd, F_GETFD);
+		cloexec_works = (fl & FD_CLOEXEC) ? 1 : -1;
+	}
+	if (cloexec_works > 0)
+		return;
+	fcntl(fd, F_SETFD, FD_CLOEXEC);
+	return;
+}
+
+static inline int open_fd(const char *path, int flags)
+{
+	int fd;
+
+#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
+	if (cloexec_works != -1)
+		flags |= O_CLOEXEC;
+#endif
+	fd = open(path, flags);
+	if (fd == -1)
+		return -1;
+	check_cloexec(fd);
+	return fd;
+}
+
+static inline int open_fd_mode(const char *path, int flags, int mode)
+{
+	int fd;
+
+#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
+	if (cloexec_works != -1)
+		flags |= O_CLOEXEC;
+#endif
+	fd = open(path, flags, mode);
+	if (fd == -1)
+		return -1;
+	check_cloexec(fd);
+	return fd;
+}
+
+static inline int open_pipe(int pipefd[2])
+{
+	int ret;
+
+#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC) && defined(__have_pipe2)
+	if (cloexec_works != -1) {
+		ret = pipe2(pipefd, O_CLOEXEC);
+		if (ret != -1)
+			return 0;
+		if (errno != EINVAL)
+			return -1;
+	}
+#endif
+	ret = pipe(pipefd);
+	if (ret == -1)
+		return -1;
+	check_cloexec(pipefd[0]);
+	check_cloexec(pipefd[1]);
+	return 0;
+}
+
+static inline int open_sock(int domain, int type, int protocol)
+{
+	int fd;
+
+#ifdef SOCK_CLOEXEC
+	if (cloexec_works != -1)
+		type |= SOCK_CLOEXEC;
+#endif
+	fd = socket(domain, type, protocol);
+	if (fd == -1)
+		return -1;
+	check_cloexec(fd);
+	return fd;
+}
+
+static inline FILE *open_fopen_r(const char *path)
+{
+	FILE *f;
+
+#if defined(O_CLOEXEC) && defined(SOCK_CLOEXEC)
+	if (cloexec_works != -1) {
+		f = fopen(path, "re");
+		if (f != NULL) {
+			check_cloexec(fileno(f));
+			return f;
+		}
+	}
+#endif
+	f = fopen(path, "r");
+	if (f == NULL)
+		return NULL;
+	check_cloexec(fileno(f));
+	return f;
+}
+
 #endif
 
diff --git a/include/state.h b/include/state.h
index d7349d9..b44a353 100644
--- a/include/state.h
+++ b/include/state.h
@@ -20,7 +20,6 @@
 #ifndef STATE_H
 #define STATE_H
 
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include <signal.h>
diff --git a/lib/cache.c b/lib/cache.c
index ce47e04..4a00367 100644
--- a/lib/cache.c
+++ b/lib/cache.c
@@ -17,10 +17,8 @@
 #include <malloc.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <ctype.h>
 #include <stdio.h>
-#include <fcntl.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/lib/defaults.c b/lib/defaults.c
index 21d76d2..ff653e3 100644
--- a/lib/defaults.c
+++ b/lib/defaults.c
@@ -21,6 +21,7 @@
 #include "defaults.h"
 #include "lookup_ldap.h"
 #include "log.h"
+#include "automount.h"
 
 #define DEFAULTS_CONFIG_FILE		AUTOFS_CONF_DIR "/autofs"
 #define MAX_LINE_LEN			256
@@ -255,7 +256,7 @@ struct list_head *defaults_get_uris(void)
 	char *res;
 	struct list_head *list;
 
-	f = fopen(DEFAULTS_CONFIG_FILE, "r");
+	f = open_fopen_r(DEFAULTS_CONFIG_FILE);
 	if (!f)
 		return NULL;
 
@@ -298,7 +299,7 @@ unsigned int defaults_read_config(unsigned int to_syslog)
 	char buf[MAX_LINE_LEN];
 	char *res;
 
-	f = fopen(DEFAULTS_CONFIG_FILE, "r");
+	f = open_fopen_r(DEFAULTS_CONFIG_FILE);
 	if (!f)
 		return 0;
 
@@ -544,7 +545,7 @@ struct ldap_searchdn *defaults_get_searchdns(void)
 	char *res;
 	struct ldap_searchdn *sdn, *last;
 
-	f = fopen(DEFAULTS_CONFIG_FILE, "r");
+	f = open_fopen_r(DEFAULTS_CONFIG_FILE);
 	if (!f)
 		return NULL;
 
diff --git a/lib/dev-ioctl-lib.c b/lib/dev-ioctl-lib.c
index 57af785..056a0a9 100644
--- a/lib/dev-ioctl-lib.c
+++ b/lib/dev-ioctl-lib.c
@@ -121,17 +121,12 @@ void init_ioctl_ctl(void)
 	if (ctl.ops)
 		return;
 
-	devfd = open(CONTROL_DEVICE, O_RDONLY);
+	devfd = open_fd(CONTROL_DEVICE, O_RDONLY);
 	if (devfd == -1)
 		ctl.ops = &ioctl_ops;
 	else {
 		struct autofs_dev_ioctl param;
 
-		int cl_flags = fcntl(devfd, F_GETFD, 0);
-		if (cl_flags != -1) {
-			cl_flags |= FD_CLOEXEC;
-			fcntl(devfd, F_SETFD, cl_flags);
-		}
 		/*
 		 * Check compile version against kernel.
 		 * Selinux may allow us to open the device but not
@@ -378,20 +373,14 @@ static int ioctl_open(unsigned int logopt,
 		      int *ioctlfd, dev_t devid, const char *path)
 {
 	struct statfs sfs;
-	int save_errno, fd, cl_flags;
+	int save_errno, fd;
 
 	*ioctlfd = -1;
 
-	fd = open(path, O_RDONLY);
+	fd = open_fd(path, O_RDONLY);
 	if (fd == -1)
 		return -1;
 
-	cl_flags = fcntl(fd, F_GETFD, 0);
-	if (cl_flags != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	if (fstatfs(fd, &sfs) == -1) {
 		save_errno = errno;
 		goto err;
diff --git a/lib/log.c b/lib/log.c
index 65e8ad2..46220fd 100644
--- a/lib/log.c
+++ b/lib/log.c
@@ -20,8 +20,6 @@
 
 #include <stdarg.h>
 #include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
 
diff --git a/lib/macros.c b/lib/macros.c
index fa6db8e..85f9cd3 100644
--- a/lib/macros.c
+++ b/lib/macros.c
@@ -14,7 +14,6 @@
  * ----------------------------------------------------------------------- */
 
 #include <malloc.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h>
diff --git a/lib/mounts.c b/lib/mounts.c
index 6d0a69c..ce4691b 100644
--- a/lib/mounts.c
+++ b/lib/mounts.c
@@ -14,13 +14,11 @@
 
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <mntent.h>
 #include <limits.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
-#include <fcntl.h>
 #include <sys/mount.h>
 #include <stdio.h>
 #include <dirent.h>
diff --git a/lib/nss_parse.y b/lib/nss_parse.y
index fa6958a..3bda6b3 100644
--- a/lib/nss_parse.y
+++ b/lib/nss_parse.y
@@ -22,8 +22,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <memory.h>
-#include <unistd.h>
-#include <fcntl.h>
 #include <limits.h>
 
 #include "automount.h"
@@ -164,9 +162,9 @@ static void parse_close_nsswitch(void *arg)
 int nsswitch_parse(struct list_head *list)
 {
 	FILE *nsswitch;
-	int fd, cl_flags, status;
+	int status;
 
-	nsswitch = fopen(NSSWITCH_FILE, "r");
+	nsswitch = open_fopen_r(NSSWITCH_FILE);
 	if (!nsswitch) {
 		logerr("couldn't open %s\n", NSSWITCH_FILE);
 		return 1;
@@ -174,13 +172,6 @@ int nsswitch_parse(struct list_head *list)
 
 	pthread_cleanup_push(parse_close_nsswitch, nsswitch);
 
-	fd = fileno(nsswitch);
-
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	parse_mutex_lock();
 	pthread_cleanup_push(parse_mutex_unlock, NULL);
 
diff --git a/lib/parse_subs.c b/lib/parse_subs.c
index 3a04dd6..8a032e8 100644
--- a/lib/parse_subs.c
+++ b/lib/parse_subs.c
@@ -18,7 +18,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
-#include <unistd.h>
 #include "automount.h"
 
 /*
diff --git a/lib/rpc_subs.c b/lib/rpc_subs.c
index 6be86c6..9ac3657 100644
--- a/lib/rpc_subs.c
+++ b/lib/rpc_subs.c
@@ -21,13 +21,11 @@
 #include <rpc/rpc.h>
 #include <rpc/pmap_prot.h>
 
-#include <unistd.h>
 #include <sys/socket.h>
 #include <netdb.h>
 #include <net/if.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-#include <sys/fcntl.h>
 #include <rpcsvc/ypclnt.h>
 #include <errno.h>
 #include <sys/ioctl.h>
@@ -36,6 +34,7 @@
 
 #include "mount.h"
 #include "rpc_subs.h"
+#include "automount.h"
 
 /* #define STANDALONE */
 #ifdef STANDALONE
@@ -59,7 +58,7 @@ inline void dump_core(void);
  */
 static CLIENT *create_udp_client(struct conn_info *info)
 {
-	int fd, cl_flags, ret, ghn_errno;
+	int fd, ret, ghn_errno;
 	CLIENT *client;
 	struct sockaddr_in laddr, raddr;
 	struct hostent hp;
@@ -115,15 +114,10 @@ got_addr:
 		 * layer, it would bind to a reserved port, which has been shown
 		 * to exhaust the reserved port range in some situations.
 		 */
-		fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
+		fd = open_sock(PF_INET, SOCK_DGRAM, IPPROTO_UDP);
 		if (fd < 0)
 			return NULL;
 
-		if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-			cl_flags |= FD_CLOEXEC;
-			fcntl(fd, F_SETFD, cl_flags);
-		}
-
 		laddr.sin_family = AF_INET;
 		laddr.sin_port = 0;
 		laddr.sin_addr.s_addr = htonl(INADDR_ANY);
@@ -274,7 +268,7 @@ done:
  */
 static CLIENT *create_tcp_client(struct conn_info *info)
 {
-	int fd, cl_flags, ghn_errno;
+	int fd, ghn_errno;
 	CLIENT *client;
 	struct sockaddr_in addr;
 	struct hostent hp;
@@ -324,15 +318,10 @@ got_addr:
 	addr.sin_port = htons(info->port);
 
 	if (!info->client) {
-		fd = socket(PF_INET, SOCK_STREAM, info->proto->p_proto);
+		fd = open_sock(PF_INET, SOCK_STREAM, info->proto->p_proto);
 		if (fd < 0)
 			return NULL;
 
-		if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-			cl_flags |= FD_CLOEXEC;
-			fcntl(fd, F_SETFD, cl_flags);
-		}
-
 		ret = connect_nb(fd, &addr, &info->timeout);
 		if (ret < 0)
 			goto out_close;
diff --git a/modules/cyrus-sasl.c b/modules/cyrus-sasl.c
index 902d9aa..286af15 100644
--- a/modules/cyrus-sasl.c
+++ b/modules/cyrus-sasl.c
@@ -51,7 +51,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <ldap.h>
 #include <sasl/sasl.h>
 
diff --git a/modules/lookup_file.c b/modules/lookup_file.c
index 9e34b72..95b9f6f 100644
--- a/modules/lookup_file.c
+++ b/modules/lookup_file.c
@@ -17,8 +17,6 @@
 #include <malloc.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
 #include <time.h>
 #include <ctype.h>
 #include <signal.h>
@@ -395,7 +393,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 	char *ent;
 	struct stat st;
 	FILE *f;
-	int fd, cl_flags;
+	int fd;
 	unsigned int path_len, ent_len;
 	int entry, cur_state;
 
@@ -422,7 +420,7 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 		return NSS_STATUS_UNAVAIL;
 	}
 
-	f = fopen(ctxt->mapname, "r");
+	f = open_fopen_r(ctxt->mapname);
 	if (!f) {
 		error(logopt,
 		      MODPREFIX "could not open master map file %s",
@@ -432,11 +430,6 @@ int lookup_read_master(struct master *master, time_t age, void *context)
 
 	fd = fileno(f);
 
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	while(1) {
 		entry = read_one(logopt, f, path, &path_len, ent, &ent_len);
 		if (!entry) {
@@ -651,7 +644,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 	char *mapent;
 	struct stat st;
 	FILE *f;
-	int fd, cl_flags;
+	int fd;
 	unsigned int k_len, m_len;
 	int entry;
 
@@ -684,7 +677,7 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 		return NSS_STATUS_UNAVAIL;
 	}
 
-	f = fopen(ctxt->mapname, "r");
+	f = open_fopen_r(ctxt->mapname);
 	if (!f) {
 		error(ap->logopt,
 		      MODPREFIX "could not open map file %s", ctxt->mapname);
@@ -693,11 +686,6 @@ int lookup_read_map(struct autofs_point *ap, time_t age, void *context)
 
 	fd = fileno(f);
 
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	while(1) {
 		entry = read_one(ap->logopt, f, key, &k_len, mapent, &m_len);
 		if (!entry) {
@@ -784,7 +772,6 @@ static int lookup_one(struct autofs_point *ap,
 	char mapent[MAPENT_MAX_LEN + 1];
 	time_t age = time(NULL);
 	FILE *f;
-	int fd, cl_flags;
 	unsigned int k_len, m_len;
 	int entry, ret;
 
@@ -794,20 +781,13 @@ static int lookup_one(struct autofs_point *ap,
 
 	mc = source->mc;
 
-	f = fopen(ctxt->mapname, "r");
+	f = open_fopen_r(ctxt->mapname);
 	if (!f) {
 		error(ap->logopt,
 		      MODPREFIX "could not open map file %s", ctxt->mapname);
 		return CHE_FAIL;
 	}
 
-	fd = fileno(f);
-
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	while(1) {
 		entry = read_one(ap->logopt, f, mkey, &k_len, mapent, &m_len);
 		if (entry) {
@@ -897,7 +877,6 @@ static int lookup_wild(struct autofs_point *ap, struct lookup_context *ctxt)
 	char mapent[MAPENT_MAX_LEN + 1];
 	time_t age = time(NULL);
 	FILE *f;
-	int fd, cl_flags;
 	unsigned int k_len, m_len;
 	int entry, ret;
 
@@ -907,20 +886,13 @@ static int lookup_wild(struct autofs_point *ap, struct lookup_context *ctxt)
 
 	mc = source->mc;
 
-	f = fopen(ctxt->mapname, "r");
+	f = open_fopen_r(ctxt->mapname);
 	if (!f) {
 		error(ap->logopt,
 		      MODPREFIX "could not open map file %s", ctxt->mapname);
 		return CHE_FAIL;
 	}
 
-	fd = fileno(f);
-
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	while(1) {
 		entry = read_one(ap->logopt, f, mkey, &k_len, mapent, &m_len);
 		if (entry) {
diff --git a/modules/lookup_hesiod.c b/modules/lookup_hesiod.c
index 737a47e..0a2ee44 100644
--- a/modules/lookup_hesiod.c
+++ b/modules/lookup_hesiod.c
@@ -10,7 +10,6 @@
 #include <ctype.h>
 #include <limits.h>
 #include <string.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <netinet/in.h>
 #include <arpa/nameser.h>
diff --git a/modules/lookup_hosts.c b/modules/lookup_hosts.c
index f8d4269..93b975a 100644
--- a/modules/lookup_hosts.c
+++ b/modules/lookup_hosts.c
@@ -15,7 +15,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <unistd.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index 42c3235..6ba80eb 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -21,7 +21,6 @@
 #include <sys/stat.h>
 #include <ctype.h>
 #include <string.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <time.h>
 #include <signal.h>
diff --git a/modules/lookup_multi.c b/modules/lookup_multi.c
index 601d48e..1bf2e0a 100644
--- a/modules/lookup_multi.c
+++ b/modules/lookup_multi.c
@@ -18,7 +18,6 @@
 #include <malloc.h>
 #include <stdio.h>
 #include <string.h>
-#include <unistd.h>
 #include <sys/stat.h>
 
 #define MODULE_LOOKUP
diff --git a/modules/lookup_nisplus.c b/modules/lookup_nisplus.c
index f15465f..4c3ce60 100644
--- a/modules/lookup_nisplus.c
+++ b/modules/lookup_nisplus.c
@@ -6,7 +6,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <unistd.h>
 #include <sys/param.h>
 #include <sys/types.h>
 #include <signal.h>
diff --git a/modules/lookup_program.c b/modules/lookup_program.c
index bf32d3b..6f4e2a3 100644
--- a/modules/lookup_program.c
+++ b/modules/lookup_program.c
@@ -18,7 +18,6 @@
 #include <malloc.h>
 #include <stdio.h>
 #include <string.h>
-#include <unistd.h>
 #include <signal.h>
 #include <sys/param.h>
 #include <sys/stat.h>
@@ -212,12 +211,12 @@ int lookup_mount(struct autofs_point *ap, const char *name, int name_len, void *
 	 * want to send stderr to the syslog, and we don't use spawnl()
 	 * because we need the pipe hooks
 	 */
-	if (pipe(pipefd)) {
+	if (open_pipe(pipefd)) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 		logerr(MODPREFIX "pipe: %s", estr);
 		goto out_free;
 	}
-	if (pipe(epipefd)) {
+	if (open_pipe(epipefd)) {
 		close(pipefd[0]);
 		close(pipefd[1]);
 		goto out_free;
diff --git a/modules/lookup_userhome.c b/modules/lookup_userhome.c
index 680ddaf..fb3caaa 100644
--- a/modules/lookup_userhome.c
+++ b/modules/lookup_userhome.c
@@ -16,7 +16,6 @@
 #include <stdio.h>
 #include <malloc.h>
 #include <pwd.h>
-#include <unistd.h>
 #include <string.h>
 #include <sys/param.h>
 #include <sys/types.h>
diff --git a/modules/lookup_yp.c b/modules/lookup_yp.c
index 1b62f57..ce438e8 100644
--- a/modules/lookup_yp.c
+++ b/modules/lookup_yp.c
@@ -16,7 +16,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <unistd.h>
 #include <time.h>
 #include <signal.h>
 #include <ctype.h>
diff --git a/modules/mount_afs.c b/modules/mount_afs.c
index 96a1367..50628ce 100644
--- a/modules/mount_afs.c
+++ b/modules/mount_afs.c
@@ -9,8 +9,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <sys/param.h>
 #include <sys/types.h>
diff --git a/modules/mount_autofs.c b/modules/mount_autofs.c
index eb63d8e..82a5ef3 100644
--- a/modules/mount_autofs.c
+++ b/modules/mount_autofs.c
@@ -16,8 +16,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <malloc.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <signal.h>
 #include <alloca.h>
diff --git a/modules/mount_bind.c b/modules/mount_bind.c
index 022d183..361f0c2 100644
--- a/modules/mount_bind.c
+++ b/modules/mount_bind.c
@@ -15,8 +15,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include <sys/param.h>
diff --git a/modules/mount_changer.c b/modules/mount_changer.c
index 43b8355..92bb72b 100644
--- a/modules/mount_changer.c
+++ b/modules/mount_changer.c
@@ -19,8 +19,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <sys/param.h>
 #include <sys/types.h>
@@ -145,25 +143,19 @@ int swapCD(const char *device, const char *slotName)
 {
 	int fd;			/* file descriptor for CD-ROM device */
 	int status;		/* return status for system calls */
-	int cl_flags;
 	int slot = -1;
 	int total_slots_available;
 
 	slot = atoi(slotName) - 1;
 
 	/* open device */
-	fd = open(device, O_RDONLY | O_NONBLOCK);
+	fd = open_fd(device, O_RDONLY | O_NONBLOCK);
 	if (fd < 0) {
 		logerr(MODPREFIX "Opening device %s failed : %s",
 		      device, strerror(errno));
 		return 1;
 	}
 
-	if ((cl_flags = fcntl(fd, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(fd, F_SETFD, cl_flags);
-	}
-
 	/* Check CD player status */
 	total_slots_available = ioctl(fd, CDROM_CHANGER_NSLOTS);
 	if (total_slots_available <= 1) {
diff --git a/modules/mount_ext2.c b/modules/mount_ext2.c
index 4c5b271..192ec04 100644
--- a/modules/mount_ext2.c
+++ b/modules/mount_ext2.c
@@ -15,8 +15,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include <sys/param.h>
diff --git a/modules/mount_generic.c b/modules/mount_generic.c
index f094d07..6d7b4b3 100644
--- a/modules/mount_generic.c
+++ b/modules/mount_generic.c
@@ -15,8 +15,6 @@
 
 #include <stdio.h>
 #include <malloc.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <string.h>
 #include <stdlib.h>
 #include <sys/param.h>
diff --git a/modules/mount_nfs.c b/modules/mount_nfs.c
index c747078..20732f8 100644
--- a/modules/mount_nfs.c
+++ b/modules/mount_nfs.c
@@ -17,8 +17,6 @@
 #include <stdio.h>
 #include <malloc.h>
 #include <netdb.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/param.h>
diff --git a/modules/parse_hesiod.c b/modules/parse_hesiod.c
index ff1f0a5..d5bb0f4 100644
--- a/modules/parse_hesiod.c
+++ b/modules/parse_hesiod.c
@@ -7,7 +7,6 @@
 #include <sys/types.h>
 #include <ctype.h>
 #include <string.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <netinet/in.h>
 #include <arpa/nameser.h>
diff --git a/modules/parse_sun.c b/modules/parse_sun.c
index 2c4f8b2..72e51e2 100644
--- a/modules/parse_sun.c
+++ b/modules/parse_sun.c
@@ -18,8 +18,6 @@
 #include <stdio.h>
 #include <malloc.h>
 #include <netdb.h>
-#include <fcntl.h>
-#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
diff --git a/modules/replicated.c b/modules/replicated.c
index b435f4b..63829a2 100644
--- a/modules/replicated.c
+++ b/modules/replicated.c
@@ -52,8 +52,6 @@
 #include <net/if.h>
 #include <netinet/in.h>
 #include <netdb.h>
-#include <unistd.h>
-#include <fcntl.h>
 
 #include "rpc_subs.h"
 #include "replicated.h"
@@ -82,7 +80,7 @@ void seed_random(void)
 	int fd;
 	unsigned int seed;
 
-	fd = open("/dev/urandom", O_RDONLY);
+	fd = open_fd("/dev/urandom", O_RDONLY);
 	if (fd < 0) {
 		srandom(time(NULL));
 		return;
@@ -145,7 +143,7 @@ static unsigned int get_proximity(const char *host_addr, int addr_len)
 	char tmp[20], buf[MAX_ERR_BUF], *ptr;
 	struct ifconf ifc;
 	struct ifreq *ifr, nmptr;
-	int sock, cl_flags, ret, i;
+	int sock, ret, i;
 	uint32_t mask, ha, ia;
 
 	memcpy(tmp, host_addr, addr_len);
@@ -153,18 +151,13 @@ static unsigned int get_proximity(const char *host_addr, int addr_len)
 
 	ha = ntohl((uint32_t) hst_addr->s_addr);
 
-	sock = socket(AF_INET, SOCK_DGRAM, 0);
+	sock = open_sock(AF_INET, SOCK_DGRAM, 0);
 	if (sock < 0) {
 		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
 		logerr("socket creation failed: %s", estr);
 		return PROXIMITY_ERROR;
 	}
 
-	if ((cl_flags = fcntl(sock, F_GETFD, 0)) != -1) {
-		cl_flags |= FD_CLOEXEC;
-		fcntl(sock, F_SETFD, cl_flags);
-	}
-
 	if (!alloc_ifreq(&ifc, sock)) {
 		close(sock);
 		return PROXIMITY_ERROR;
